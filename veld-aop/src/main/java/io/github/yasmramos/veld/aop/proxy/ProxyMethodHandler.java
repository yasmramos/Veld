/*
 * Copyright 2025 Veld Framework
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.yasmramos.veld.aop.proxy;

import io.github.yasmramos.veld.aop.InterceptorRegistry;
import io.github.yasmramos.veld.aop.InvocationContext;
import io.github.yasmramos.veld.aop.MethodInterceptor;
import io.github.yasmramos.veld.aop.MethodInvocation;

import java.lang.reflect.Method;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Handles method invocations on proxy objects.
 *
 * <p>This class provides two invocation paths:
 * <ul>
 *   <li>{@link #invoke(Object, String, String, Object[])} - legacy path with method name/descriptor</li>
 *   <li>{@link #invokeOptimized(int, Object, Object[])} - optimized path with method index</li>
 * </ul>
 *
 * <p>The optimized path eliminates string-based method lookup by using
 * pre-computed method indices, improving performance significantly.
 *
 * @author Veld Framework Team
 * @since 1.0.0-alpha.5
 */
public class ProxyMethodHandler {

    private static final Map<String, Method> methodCache = new ConcurrentHashMap<>();
    private static final Map<MethodKey, CachedInvocation> INVOCATION_CACHE = new ConcurrentHashMap<>();

    /**
     * Key for caching method invocations.
     */
    private static final class MethodKey {
        private final Class<?> targetClass;
        private final String methodName;
        private final Class<?>[] paramTypes;
        private final int hashCode;

        MethodKey(Class<?> targetClass, String methodName, Class<?>[] paramTypes) {
            this.targetClass = targetClass;
            this.methodName = methodName;
            this.paramTypes = paramTypes;
            this.hashCode = computeHashCode();
        }

        private int computeHashCode() {
            int result = targetClass.hashCode();
            result = 31 * result + methodName.hashCode();
            result = 31 * result;
            for (Class<?> param : paramTypes) {
                result = 31 * result + (param != null ? param.hashCode() : 0);
            }
            return result;
        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (!(obj instanceof MethodKey)) return false;
            MethodKey other = (MethodKey) obj;
            return targetClass == other.targetClass &&
                   methodName.equals(other.methodName) &&
                   java.util.Arrays.equals(paramTypes, other.paramTypes);
        }
    }

    /**
     * Cached invocation information.
     */
    private static final class CachedInvocation {
        final Method method;
        final List<MethodInterceptor> interceptors;

        CachedInvocation(Method method, List<MethodInterceptor> interceptors) {
            this.method = method;
            this.interceptors = interceptors;
        }
    }

    /**
     * Invokes a method through the interceptor chain.
     *
     * <p>This method is called from generated proxy bytecode using the
     * legacy invocation pattern with method name and descriptor.
     *
     * @param target           the target object
     * @param methodName       the method name
     * @param methodDescriptor the method descriptor
     * @param args             the method arguments
     * @return the result of the invocation
     * @throws Throwable if the method or interceptor throws an exception
     */
    public static Object invoke(Object target, String methodName,
                                 String methodDescriptor, Object[] args) throws Throwable {
        // Find the method
        Method method = findMethod(target.getClass(), methodName, methodDescriptor);

        // Get interceptors
        List<MethodInterceptor> interceptors = InterceptorRegistry.getInstance()
                .getInterceptors(method);

        if (interceptors.isEmpty()) {
            // No interceptors, call directly
            method.setAccessible(true);
            return method.invoke(target, args);
        }

        // Create invocation context and proceed through chain
        MethodInvocation invocation = new MethodInvocation(target, method, args, interceptors);
        return invocation.proceed();
    }

    /**
     * Optimized invocation entry point for generated bytecode.
     *
     * <p>This method is called from optimized proxy bytecode when interceptors
     * are present. It uses pre-computed method indices to avoid string lookups.
     *
     * @param methodIndex the index of the method in the proxied class
     * @param target      the target object
     * @param args        the method arguments
     * @return the result of the invocation
     * @throws Throwable if the method or interceptor throws an exception
     */
    public static Object invokeOptimized(int methodIndex, Object target, Object[] args) throws Throwable {
        // Get the proxy to find the method
        if (!(target instanceof AopProxy)) {
            throw new IllegalArgumentException("Target must implement AopProxy");
        }

        AopProxy aopProxy = (AopProxy) target;
        Class<?> targetClass = aopProxy.getTargetClass();

        // Find the method from the proxy class
        Method method = findMethodFromProxy(aopProxy, methodIndex);

        if (method == null) {
            throw new IllegalStateException("Method not found at index: " + methodIndex);
        }

        // Get or create cached invocation
        CachedInvocation cached = getOrCreateInvocation(targetClass, method);

        if (cached.interceptors.isEmpty()) {
            // No interceptors, call directly
            method.setAccessible(true);
            return method.invoke(target, args);
        }

        // Execute interceptor chain
        MethodInvocation invocation = new MethodInvocation(target, method, args, cached.interceptors);
        return invocation.proceed();
    }

    /**
     * Gets or creates a cached invocation for the given method.
     */
    private static CachedInvocation getOrCreateInvocation(Class<?> targetClass, Method method) {
        Class<?>[] paramTypes = method.getParameterTypes();
        MethodKey key = new MethodKey(targetClass, method.getName(), paramTypes);

        return INVOCATION_CACHE.computeIfAbsent(key, k -> {
            List<MethodInterceptor> interceptors = InterceptorRegistry.getInstance().getInterceptors(method);
            return new CachedInvocation(method, interceptors);
        });
    }

    /**
     * Finds a method from the proxy class by index.
     */
    private static Method findMethodFromProxy(AopProxy proxy, int methodIndex) {
        Class<?> targetClass = proxy.getTargetClass();

        // Collect methods that should be proxied
        java.util.List<Method> proxiedMethods = new java.util.ArrayList<>();
        for (Method method : targetClass.getMethods()) {
            if (shouldProxy(method)) {
                proxiedMethods.add(method);
            }
        }

        if (methodIndex >= 0 && methodIndex < proxiedMethods.size()) {
            return proxiedMethods.get(methodIndex);
        }

        return null;
    }

    /**
     * Determines whether a method should be proxied.
     */
    private static boolean shouldProxy(Method method) {
        int mods = method.getModifiers();

        // Skip static, final, private methods
        if (java.lang.reflect.Modifier.isStatic(mods) ||
            java.lang.reflect.Modifier.isFinal(mods) ||
            java.lang.reflect.Modifier.isPrivate(mods)) {
            return false;
        }

        // Skip Object methods (except toString, equals, hashCode)
        if (method.getDeclaringClass() == Object.class) {
            String name = method.getName();
            return "toString".equals(name) || "equals".equals(name) || "hashCode".equals(name);
        }

        // Skip synthetic and bridge methods
        if (method.isSynthetic() || method.isBridge()) {
            return false;
        }

        return true;
    }

    private static Method findMethod(Class<?> targetClass, String methodName,
                                      String descriptor) {
        String cacheKey = targetClass.getName() + "#" + methodName + descriptor;

        return methodCache.computeIfAbsent(cacheKey, key -> {
            Class<?>[] paramTypes = parseDescriptor(descriptor);
            try {
                return targetClass.getMethod(methodName, paramTypes);
            } catch (NoSuchMethodException e) {
                // Try declared methods
                try {
                    Method method = targetClass.getDeclaredMethod(methodName, paramTypes);
                    method.setAccessible(true);
                    return method;
                } catch (NoSuchMethodException e2) {
                    throw new RuntimeException("Method not found: " + methodName, e2);
                }
            }
        });
    }

    /**
     * Parses a method descriptor to get parameter types.
     */
    private static Class<?>[] parseDescriptor(String descriptor) {
        // Format: (param1param2...)returnType
        // Examples: ()V, (I)V, (Ljava/lang/String;)I

        java.util.List<Class<?>> params = new java.util.ArrayList<>();
        int i = 1; // Skip opening '('

        while (i < descriptor.length() && descriptor.charAt(i) != ')') {
            int start = i;
            char c = descriptor.charAt(i);

            if (c == 'L') {
                // Object type: Lpackage/Class;
                int end = descriptor.indexOf(';', i);
                String className = descriptor.substring(i + 1, end).replace('/', '.');
                params.add(loadClass(className));
                i = end + 1;
            } else if (c == '[') {
                // Array type
                while (descriptor.charAt(i) == '[') {
                    i++;
                }
                c = descriptor.charAt(i);
                if (c == 'L') {
                    int end = descriptor.indexOf(';', i);
                    String className = descriptor.substring(start, end + 1).replace('/', '.');
                    params.add(loadClass(toArrayClassName(descriptor.substring(start, end + 1))));
                    i = end + 1;
                } else {
                    params.add(loadClass(toArrayClassName(descriptor.substring(start, i + 1))));
                    i++;
                }
            } else {
                // Primitive type
                params.add(getPrimitiveType(c));
                i++;
            }
        }

        return params.toArray(new Class<?>[0]);
    }

    private static String toArrayClassName(String descriptor) {
        return descriptor.replace('/', '.');
    }

    private static Class<?> loadClass(String className) {
        try {
            // Handle array notation
            if (className.startsWith("[")) {
                return Class.forName(className);
            }
            return Class.forName(className);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("Class not found: " + className, e);
        }
    }

    private static Class<?> getPrimitiveType(char c) {
        switch (c) {
            case 'I': return int.class;
            case 'J': return long.class;
            case 'D': return double.class;
            case 'F': return float.class;
            case 'Z': return boolean.class;
            case 'B': return byte.class;
            case 'C': return char.class;
            case 'S': return short.class;
            case 'V': return void.class;
            default: throw new IllegalArgumentException("Unknown primitive: " + c);
        }
    }
}
