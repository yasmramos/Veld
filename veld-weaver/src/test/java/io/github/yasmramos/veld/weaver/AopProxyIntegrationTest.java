package io.github.yasmramos.veld.weaver;

import org.junit.jupiter.api.Test;
import org.objectweb.asm.ClassReader;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * E2E Integration test for AOP proxy generation.
 * Verifies the complete flow: metadata -> proxy generation -> class structure.
 */
class AopProxyIntegrationTest {

    @Test
    void testProxyClassGeneration() {
        // Given: component metadata with AOP requirements
        String targetClass = "com/example/UserService";
        AopProxyGenerator.MethodMeta method = new AopProxyGenerator.MethodMeta(
            "findUser", "(Ljava/lang/String;)Ljava/lang/Object;", List.of("@Logged")
        );
        AopProxyGenerator.ProxyMeta proxyMeta = new AopProxyGenerator.ProxyMeta(
            targetClass, List.of(method), List.of("com/example/LoggingInterceptor")
        );
        
        // When: generate proxy
        AopProxyGenerator generator = new AopProxyGenerator(List.of(proxyMeta));
        Map<String, byte[]> generated = generator.generateAll();
        
        // Then: proxy class is generated with correct name
        String expectedProxyName = targetClass + "$AopProxy";
        assertTrue(generated.containsKey(expectedProxyName), 
            "Should generate proxy class: " + expectedProxyName);
        
        byte[] bytecode = generated.get(expectedProxyName);
        assertNotNull(bytecode);
        assertTrue(bytecode.length > 0, "Bytecode should not be empty");
    }

    @Test
    void testProxyClassStructure() {
        // Given
        String targetClass = "com/example/OrderService";
        AopProxyGenerator.MethodMeta method1 = new AopProxyGenerator.MethodMeta(
            "createOrder", "()V", List.of("@Transactional")
        );
        AopProxyGenerator.MethodMeta method2 = new AopProxyGenerator.MethodMeta(
            "getOrder", "(I)Ljava/lang/Object;", List.of("@Cached")
        );
        AopProxyGenerator.ProxyMeta proxyMeta = new AopProxyGenerator.ProxyMeta(
            targetClass, List.of(method1, method2), List.of()
        );
        
        // When
        AopProxyGenerator generator = new AopProxyGenerator(List.of(proxyMeta));
        Map<String, byte[]> generated = generator.generateAll();
        
        byte[] bytecode = generated.get(targetClass + "$AopProxy");
        ClassReader cr = new ClassReader(bytecode);
        
        // Then: verify class extends target
        assertEquals(targetClass, cr.getSuperName(), 
            "Proxy should extend original class");
        
        // Verify proxy class name
        assertEquals(targetClass + "$AopProxy", cr.getClassName(),
            "Proxy class name should have $AopProxy suffix");
    }

    @Test
    void testMultipleProxiesGeneration() {
        // Given: multiple components need proxies
        AopProxyGenerator.ProxyMeta proxy1 = new AopProxyGenerator.ProxyMeta(
            "com/app/ServiceA",
            List.of(new AopProxyGenerator.MethodMeta("doA", "()V", List.of())),
            List.of()
        );
        AopProxyGenerator.ProxyMeta proxy2 = new AopProxyGenerator.ProxyMeta(
            "com/app/ServiceB",
            List.of(new AopProxyGenerator.MethodMeta("doB", "(I)I", List.of())),
            List.of()
        );
        
        // When
        AopProxyGenerator generator = new AopProxyGenerator(List.of(proxy1, proxy2));
        Map<String, byte[]> generated = generator.generateAll();
        
        // Then: both proxies are generated
        assertEquals(2, generated.size());
        assertTrue(generated.containsKey("com/app/ServiceA$AopProxy"));
        assertTrue(generated.containsKey("com/app/ServiceB$AopProxy"));
    }

    @Test
    void testProxyMethodOverrides() {
        // Given
        String targetClass = "com/example/TestComponent";
        AopProxyGenerator.MethodMeta method = new AopProxyGenerator.MethodMeta(
            "process", "(Ljava/lang/String;I)Ljava/lang/String;", List.of()
        );
        AopProxyGenerator.ProxyMeta proxyMeta = new AopProxyGenerator.ProxyMeta(
            targetClass, List.of(method), List.of()
        );
        
        // When
        AopProxyGenerator generator = new AopProxyGenerator(List.of(proxyMeta));
        Map<String, byte[]> generated = generator.generateAll();
        
        byte[] bytecode = generated.get(targetClass + "$AopProxy");
        
        // Then: bytecode is valid and can be read
        ClassReader cr = new ClassReader(bytecode);
        assertDoesNotThrow(() -> cr.accept(new org.objectweb.asm.ClassVisitor(org.objectweb.asm.Opcodes.ASM9) {}, 0),
            "Generated bytecode should be valid");
    }

    @Test
    void testVeldClassGeneratorAopIntegration() {
        // Given: ComponentMeta with AOP enabled
        String componentClass = "com.example.MyComponent";
        VeldClassGenerator.AopMethodMeta aopMethod = new VeldClassGenerator.AopMethodMeta(
            "execute", "()V", List.of("@Timed")
        );
        
        VeldClassGenerator.ComponentMeta compMeta = new VeldClassGenerator.ComponentMeta(
            componentClass,      // className
            "SINGLETON",         // scope
            false,               // lazy
            List.of(),           // constructorDeps
            List.of(),           // fieldInjections
            List.of(),           // methodInjections
            List.of(),           // interfaces
            null,                // postConstructMethod
            null,                // postConstructDescriptor
            null,                // preDestroyMethod
            null,                // preDestroyDescriptor
            false,               // hasSubscribeMethods
            null,                // componentName
            List.of(),           // explicitDependencies
            true,                // needsAopProxy
            List.of(aopMethod),  // aopMethods
            List.of("com.example.TimingInterceptor")  // interceptorClasses
        );
        
        // Then: verify AOP fields are set correctly
        assertTrue(compMeta.needsAopProxy);
        assertEquals(1, compMeta.aopMethods.size());
        assertEquals("execute", compMeta.aopMethods.get(0).name);
        assertEquals(1, compMeta.interceptorClasses.size());
    }

    @Test
    void testEmptyProxyList() {
        // Given: no proxies needed
        AopProxyGenerator generator = new AopProxyGenerator(List.of());
        
        // When
        Map<String, byte[]> generated = generator.generateAll();
        
        // Then
        assertTrue(generated.isEmpty(), "Should return empty map when no proxies needed");
    }
}
