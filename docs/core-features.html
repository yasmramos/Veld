<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Features - Veld DI Framework</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <a href="index.html" class="logo">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;">
                        <path d="M12 2L2 7v10c0 5.55 3.84 9.74 9 11 5.16-1.26 9-5.45 9-11V7l-10-5z"/>
                    </svg>
                    Veld
                </a>
                
                <nav>
                    <ul class="nav-menu">
                        <li><a href="getting-started.html">Getting Started</a></li>
                        <li><a href="annotations.html">Annotations</a></li>
                        <li><a href="core-features.html" class="active">Core Features</a></li>
                        <li><a href="aop.html">AOP</a></li>
                        <li><a href="eventbus.html">EventBus</a></li>
                <li><a href="spring-boot.html">Spring Boot Integration</a></li>
                        <li><a href="spring-boot.html">Spring Boot</a></li>
                        <li><a href="spring-boot.html">Spring Boot</a></li>
                        <li><a href="api.html">API Reference</a></li>
                        <li><a href="examples.html">Examples</a></li>
                    </ul>
                </nav>
                
                <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">‚ò∞</button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-layout">
        <!-- Sidebar Navigation -->
        <nav class="sidebar">
            <h3>Documentation</h3>
            <ul class="sidebar-nav">
                <li><a href="index.html">Overview</a></li>
                <li><a href="getting-started.html">Getting Started</a></li>
                <li><a href="installation.html">Installation</a></li>
                <li><a href="annotations.html">Annotations Reference</a></li>
                <li><a href="core-features.html" class="active">Core Features</a>
                    <ul class="sub-nav">
                        <li><a href="#dependency-injection">Dependency Injection</a></li>
                        <li><a href="#scopes">Scopes</a></li>
                        <li><a href="#configuration">Configuration</a></li>
                        <li><a href="#lifecycle">Lifecycle</a></li>
                    </ul>
                </li>
                <li><a href="aop.html">Aspect-Oriented Programming</a></li>
                <li><a href="eventbus.html">EventBus</a></li>
                <li><a href="spring-boot.html">Spring Boot Integration</a></li>
                        <li><a href="spring-boot.html">Spring Boot</a></li>
                <li><a href="spring-boot.html">Spring Boot Integration</a></li>
                <li><a href="optimizations.html">Phase 1 Optimizations</a></li>
                <li><a href="api.html">API Reference</a></li>
                <li><a href="examples.html">Examples</a></li>
            </ul>
        </nav>

        <!-- Content -->
        <div class="content">
            <h1>‚öôÔ∏è Core Features</h1>
            
            <div class="alert alert-info">
                <strong>üéØ Overview:</strong> Veld provides a comprehensive set of features for dependency injection, configuration management, and application lifecycle control.
            </div>

            <!-- Dependency Injection -->
            <section id="dependency-injection">
                <h2>üíâ Dependency Injection</h2>
                
                <div class="card">
                    <h3>Multiple Injection Patterns</h3>
                    <p>Veld supports flexible dependency injection patterns to suit different coding styles and requirements:</p>
                    
                    <h4>Constructor Injection (Recommended)</h4>
                    <p>Constructor injection is the preferred method as it makes dependencies explicit and enables better testability.</p>
<pre><code>@Component
@Singleton
public class OrderService {
    private final UserRepository userRepository;
    private final OrderRepository orderRepository;
    private final EmailService emailService;
    
    @Inject
    public OrderService(
        UserRepository userRepository,
        OrderRepository orderRepository,
        EmailService emailService
    ) {
        this.userRepository = userRepository;
        this.orderRepository = orderRepository;
        this.emailService = emailService;
    }
    
    public void processOrder(String userId, List&lt;OrderItem&gt; items) {
        User user = userRepository.findById(userId);
        Order order = orderRepository.create(user, items);
        emailService.sendOrderConfirmation(user.getEmail(), order);
    }
}</code></pre>

                    <h4>Field Injection</h4>
                    <p>Field injection provides a concise syntax but makes dependencies less explicit.</p>
<pre><code>@Component
@Singleton
public class ReportService {
    
    @Inject
    private UserRepository userRepository;
    
    @Inject
    private OrderRepository orderRepository;
    
    @Inject
    private EmailService emailService;
    
    public Report generateUserReport(String userId) {
        User user = userRepository.findById(userId);
        List&lt;Order&gt; orders = orderRepository.findByUserId(userId);
        return new Report(user, orders);
    }
}</code></pre>

                    <h4>Method Injection</h4>
                    <p>Method injection allows for custom initialization logic and parameter validation.</p>
<pre><code>@Component
@Singleton
public class CacheService {
    private DatabaseService databaseService;
    private CacheStrategy cacheStrategy;
    
    @Inject
    public void initialize(DatabaseService databaseService, CacheStrategy strategy) {
        if (databaseService == null) {
            throw new IllegalArgumentException("DatabaseService is required");
        }
        this.databaseService = databaseService;
        this.cacheStrategy = strategy;
        cacheStrategy.initialize();
    }
}</code></pre>
                </div>

                <div class="card">
                    <h3>Advanced Injection Features</h3>
                    
                    <h4>Private Field Injection</h4>
                    <p>Veld can inject into private, static, and final fields without using reflection.</p>
<pre><code>@Component
@Singleton
public class SecureService {
    
    @Inject
    private SecurityManager securityManager;
    
    @Inject
    private static AuditLogger auditLogger;  // Static field injection
    
    @Inject
    private final Configuration config;  // Final field injection
}</code></pre>

                    <h4>Provider Injection for Lazy Loading</h4>
                    <p>Use Provider for on-demand component creation and to break circular dependencies.</p>
<pre><code>@Component
@Singleton
public class LazyService {
    
    @Inject
    private Provider&lt;ExpensiveService&gt; expensiveServiceProvider;
    
    public void performOperation() {
        // ExpensiveService is created only when needed
        ExpensiveService service = expensiveServiceProvider.get();
        service.performExpensiveOperation();
    }
    
    public void performBatchOperations(int count) {
        for (int i = 0; i &lt; count; i++) {
            // Each call creates a new instance
            expensiveServiceProvider.get().performOperation();
        }
    }
}</code></pre>

                    <h4>Optional Injection</h4>
                    <p>Inject optional dependencies that may not always be present.</p>
<pre><code>@Component
public class AnalyticsService {
    
    @Inject
    @Optional
    private Optional&lt;AnalyticsProvider&gt; analyticsProvider;
    
    @Inject
    @Optional
    private Provider&lt;MetricsCollector&gt; metricsCollector;
    
    public void trackEvent(String event) {
        if (analyticsProvider.isPresent()) {
            analyticsProvider.get().track(event);
        }
        
        // MetricsCollector might not be configured
        metricsCollector.ifPresent(collector -&gt; {
            collector.recordEvent(event);
        });
    }
}</code></pre>
                </div>
            </section>

            <!-- Scopes -->
            <section id="scopes">
                <h2>üîÑ Scope Management</h2>
                
                <div class="card">
                    <h3>Built-in Scopes</h3>
                    <p>Veld provides several built-in scopes to control component lifecycle:</p>
                    
                    <h4>@Singleton Scope</h4>
                    <p>Creates a single instance shared across the entire application context.</p>
<pre><code>@Component
@Singleton
public class DatabaseConnection {
    private final Connection connection;
    
    @Inject
    public DatabaseConnection(@Value("${database.url}") String url) {
        this.connection = DriverManager.getConnection(url);
    }
    
    public Connection getConnection() {
        return connection;
    }
}</code></pre>

                    <h4>@Prototype Scope</h4>
                    <p>Creates a new instance for each injection request.</p>
<pre><code>@Component
@Prototype
public class RequestHandler {
    private final String requestId;
    private final Instant createdAt;
    
    public RequestHandler() {
        this.requestId = UUID.randomUUID().toString();
        this.createdAt = Instant.now();
    }
    
    public void handleRequest(String data) {
        System.out.println("Request " + requestId + " created at " + createdAt);
        // Process the request
    }
}</code></pre>

                    <h4>@Lazy Scope</h4>
                    <p>Defers component creation until the component is first accessed.</p>
<pre><code>@Component
@Singleton
@Lazy
public class HeavyInitializationService {
    private final ExpensiveResource resource;
    
    public HeavyInitializationService() {
        // This constructor might be expensive
        System.out.println("Creating HeavyInitializationService...");
        this.resource = initializeExpensiveResource();
    }
    
    private ExpensiveResource initializeExpensiveResource() {
        // Simulate expensive initialization
        try {
            Thread.sleep(2000); // 2 seconds
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return new ExpensiveResource();
    }
}</code></pre>
                </div>

                <div class="card">
                    <h3>Custom Scopes</h3>
                    <p>Create your own scope definitions for specialized lifecycle patterns:</p>
                    
<pre><code>// Define custom scope annotation
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface SessionScope {
    // Scope definition
}

// Create scope implementation
public class SessionScopeImpl implements Scope {
    private final Map&lt;String, Object&gt; sessionData = new ConcurrentHashMap&lt;&gt;();
    
    @Override
    public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) {
        return sessionData.computeIfAbsent(name, key -&gt; objectFactory.getObject());
    }
    
    public void invalidate() {
        sessionData.clear();
    }
}</code></pre>
                </div>

                <div class="card">
                    <h3>Scope Configuration</h3>
                    <p>Configure scopes through application properties:</p>
                    
<pre><code># Configure default scope for components
veld.scope.default=singleton

# Configure prototype scope for specific packages
veld.scope.prototype.pattern=com.example.request.**

# Configure session scope timeout (in minutes)
veld.session.timeout=30</code></pre>
                </div>
            </section>

            <!-- Configuration -->
            <section id="configuration">
                <h2>‚öôÔ∏è Configuration Management</h2>
                
                <div class="card">
                    <h3>Flexible Configuration Sources</h3>
                    <p>Veld supports multiple configuration sources with automatic precedence handling:</p>
                    
                    <h4>Configuration Sources (Precedence Order)</h4>
                    <ol>
                        <li><strong>Command-line arguments:</strong> -Dproperty=value</li>
                        <li><strong>System properties:</strong> System.getProperty("property")</li>
                        <li><strong>Environment variables:</strong> $ENV_VAR or ${ENV_VAR}</li>
                        <li><strong>Configuration files:</strong> application.properties, application.yml</li>
                        <li><strong>Default values:</strong> Specified in @Value annotation</li>
                    </ol>

                    <h4>Basic Configuration</h4>
<pre><code>@Component
public class AppConfig {
    
    @Value("${app.name}")
    private String appName;
    
    @Value("${app.version}")
    private String version;
    
    @Value("${app.debug:false}")  // Default value
    private boolean debug;
    
    @Value("${database.pool.size:10}")
    private int poolSize;
}</code></pre>

                    <h4>Configuration File Example</h4>
                    <p><strong>application.properties:</strong></p>
<pre><code># Application configuration
app.name=MyVeldApplication
app.version=1.0.0
app.debug=true

# Database configuration
database.url=jdbc:postgresql://localhost:5432/mydb
database.username=admin
database.password=${DB_PASSWORD}  # From environment
database.pool.size=20

# Cache configuration
cache.enabled=true
cache.ttl=3600
cache.provider=redis

# Redis configuration
redis.host=localhost
redis.port=6379
redis.password=${REDIS_PASSWORD}  # From environment</code></pre>

                    <p><strong>application.yml:</strong></p>
<pre><code>app:
  name: MyVeldApplication
  version: 1.0.0
  debug: true

database:
  url: jdbc:postgresql://localhost:5432/mydb
  username: admin
  password: ${DB_PASSWORD}
  pool:
    size: 20

cache:
  enabled: true
  ttl: 3600
  provider: redis

redis:
  host: localhost
  port: 6379
  password: ${REDIS_PASSWORD}</code></pre>
                </div>

                <div class="card">
                    <h3>Advanced Configuration Features</h3>
                    
                    <h4>Configuration Classes</h4>
                    <p>Group related configuration properties into cohesive classes:</p>
                    
<pre><code>@Component
public class DatabaseConfig {
    
    @Value("${database.url}")
    private String url;
    
    @Value("${database.username}")
    private String username;
    
    @Value("${database.password}")
    private String password;
    
    @Value("${database.pool.size:10}")
    private int poolSize;
    
    @Value("${database.timeout:30}")
    private int timeout;
    
    // Configuration validation
    @PostConstruct
    public void validate() {
        if (url == null || url.trim().isEmpty()) {
            throw new IllegalArgumentException("Database URL is required");
        }
        if (poolSize &lt;= 0) {
            throw new IllegalArgumentException("Pool size must be positive");
        }
    }
    
    // Factory method for creating connections
    public Connection createConnection() throws SQLException {
        return DriverManager.getConnection(url, username, password);
    }
}</code></pre>

                    <h4>Environment-Specific Configuration</h4>
                    
<pre><code>// Environment-specific configuration files
application-dev.properties    # Development environment
application-test.properties   # Test environment
application-prod.properties   # Production environment

// Or use profiles
spring.profiles.active=dev    # Activates application-dev.properties</code></pre>

                    <h4>Dynamic Configuration Updates</h4>
                    
<pre><code>@Component
public class DynamicConfig {
    
    @Value("${cache.ttl}")
    private volatile int cacheTtl;
    
    @Value("${feature.new-ui:false}")
    private volatile boolean newUiEnabled;
    
    // Methods to access current values
    public int getCacheTtl() {
        return cacheTtl;
    }
    
    public boolean isNewUiEnabled() {
        return newUiEnabled;
    }
    
    // Reload configuration
    public void reloadConfiguration() {
        // Re-read properties file
        // Update volatile fields
    }
}</code></pre>
                </div>

                <div class="card">
                    <h3>Conditional Configuration</h3>
                    <p>Use conditional annotations to create environment-specific implementations:</p>
                    
<pre><code>// Production configuration
@Component
@ConditionalOnProperty(name = "app.environment", havingValue = "production")
public class ProductionDatabaseConfig implements DatabaseConfig {
    
    @Value("${database.url}")
    private String url;
    
    @Value("${database.ssl.enabled:true}")
    private boolean sslEnabled;
    
    @Override
    public Connection createConnection() throws SQLException {
        Properties props = new Properties();
        props.setProperty("ssl", sslEnabled ? "require" : "disable");
        return DriverManager.getConnection(url, props);
    }
}

// Development configuration
@Component
@ConditionalOnProperty(name = "app.environment", havingValue = "development")
public class DevelopmentDatabaseConfig implements DatabaseConfig {
    
    @Value("${database.url}")
    private String url;
    
    @Value("${database.mock:false}")
    private boolean useMock;
    
    @Override
    public Connection createConnection() throws SQLException {
        if (useMock) {
            return new MockConnection();  // Mock implementation for development
        }
        return DriverManager.getConnection(url);
    }
}</code></pre>
                </div>
            </section>

            <!-- Lifecycle -->
            <section id="lifecycle">
                <h2>üîÑ Lifecycle Management</h2>
                
                <div class="card">
                    <h3>Component Lifecycle Callbacks</h3>
                    <p>Veld provides lifecycle hooks for initialization and cleanup:</p>
                    
                    <h4>Initialization with @PostConstruct</h4>
                    
<pre><code>@Component
@Singleton
public class DatabaseService {
    private ConnectionPool connectionPool;
    
    @Inject
    public DatabaseService(DatabaseConfig config) {
        this.config = config;
    }
    
    @PostConstruct
    public void initialize() {
        System.out.println("Initializing DatabaseService...");
        
        // Validate configuration
        validateConfiguration();
        
        // Initialize connection pool
        connectionPool = new ConnectionPool(config);
        connectionPool.initialize();
        
        // Perform startup checks
        performHealthCheck();
        
        System.out.println("DatabaseService initialized successfully");
    }
    
    private void validateConfiguration() {
        if (config.getPoolSize() &lt;= 0) {
            throw new IllegalStateException("Invalid pool size: " + config.getPoolSize());
        }
    }
    
    private void performHealthCheck() {
        try (Connection conn = connectionPool.getConnection()) {
            // Test database connectivity
            ResultSet rs = conn.createStatement().executeQuery("SELECT 1");
            if (rs.next() && rs.getInt(1) == 1) {
                System.out.println("Database connectivity check passed");
            }
        } catch (SQLException e) {
            throw new IllegalStateException("Database connectivity check failed", e);
        }
    }
}</code></pre>

                    <h4>Cleanup with @PreDestroy</h4>
                    
<pre><code>@Component
@Singleton
public class CacheService {
    private RedisClient redisClient;
    private ScheduledExecutorService cleanupExecutor;
    
    @Inject
    public CacheService(CacheConfig config) {
        this.config = config;
    }
    
    @PostConstruct
    public void initialize() {
        redisClient = new RedisClient(config.getRedisUrl());
        redisClient.connect();
        
        // Start cleanup scheduler
        cleanupExecutor = Executors.newScheduledThreadPool(1);
        cleanupExecutor.scheduleAtFixedRate(this::cleanupExpiredEntries, 
                                           1, 1, TimeUnit.HOURS);
    }
    
    @PreDestroy
    public void cleanup() {
        System.out.println("Shutting down CacheService...");
        
        // Stop scheduler
        if (cleanupExecutor != null) {
            cleanupExecutor.shutdown();
            try {
                if (!cleanupExecutor.awaitTermination(30, TimeUnit.SECONDS)) {
                    cleanupExecutor.shutdownNow();
                }
            } catch (InterruptedException e) {
                cleanupExecutor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
        
        // Close Redis connection
        if (redisClient != null) {
            redisClient.disconnect();
        }
        
        System.out.println("CacheService shutdown completed");
    }
    
    private void cleanupExpiredEntries() {
        // Clean up expired cache entries
        long cleaned = redisClient.cleanExpiredEntries();
        if (cleaned &gt; 0) {
            System.out.println("Cleaned " + cleaned + " expired cache entries");
        }
    }
}</code></pre>
                </div>

                <div class="card">
                    <h3>Application Lifecycle Management</h3>
                    
                    <h4>Application Start and Stop</h4>
                    
<pre><code>@Component
public class ApplicationLifecycleManager {
    
    @Inject
    private List&lt;Initializable&gt; initializables;
    
    @Inject
    private List&lt;Disposable&gt; disposables;
    
    @Inject
    private EventBus eventBus;
    
    public void startApplication() {
        System.out.println("Starting application...");
        
        try {
            // Publish startup event
            eventBus.publish(new ApplicationStartingEvent());
            
            // Initialize all components
            for (Initializable initializable : initializables) {
                initializable.initialize();
            }
            
            // Publish started event
            eventBus.publish(new ApplicationStartedEvent());
            
            System.out.println("Application started successfully");
        } catch (Exception e) {
            System.err.println("Failed to start application: " + e.getMessage());
            shutdownApplication();
            throw new RuntimeException("Application startup failed", e);
        }
    }
    
    public void shutdownApplication() {
        System.out.println("Shutting down application...");
        
        try {
            // Publish shutdown event
            eventBus.publish(new ApplicationShuttingDownEvent());
            
            // Dispose all components in reverse order
            Collections.reverse(disposables);
            for (Disposable disposable : disposables) {
                disposable.dispose();
            }
            
            // Publish shutdown complete event
            eventBus.publish(new ApplicationShutdownCompleteEvent());
            
            System.out.println("Application shutdown completed");
        } catch (Exception e) {
            System.err.println("Error during application shutdown: " + e.getMessage());
        }
    }
}</code></pre>

                    <h4>Graceful Shutdown</h4>
                    
<pre><code>@Component
public class GracefulShutdownHandler {
    
    private volatile boolean shutdownRequested = false;
    
    public void registerShutdownHook() {
        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {
            shutdownRequested = true;
            performGracefulShutdown();
        }));
    }
    
    private void performGracefulShutdown() {
        System.out.println("Performing graceful shutdown...");
        
        // Stop accepting new requests
        stopAcceptingRequests();
        
        // Wait for ongoing requests to complete
        awaitOngoingRequests(30, TimeUnit.SECONDS);
        
        // Force shutdown if necessary
        if (hasOngoingRequests()) {
            System.out.println("Force shutdown after timeout");
        }
    }
}</code></pre>
                </div>

                <div class="card">
                    <h3>Circular Dependency Detection</h3>
                    <p>Veld detects circular dependencies at compile time and provides clear error messages:</p>
                    
<pre><code>// This would cause a circular dependency error:
@Component
public class ServiceA {
    @Inject
    private ServiceB serviceB;
}

@Component
public class ServiceB {
    @Inject
    private ServiceA serviceA;  // Circular dependency!
}

// Compile error message:
// Circular dependency detected:
// ServiceA -&gt; ServiceB -&gt; ServiceA
// 
// Solution: Use Provider to break the cycle
@Component
public class ServiceA {
    @Inject
    private Provider&lt;ServiceB&gt; serviceBProvider;
    
    public void doSomething() {
        ServiceB serviceB = serviceBProvider.get();  // Break the cycle
        serviceB.doSomethingElse();
    }
}</code></pre>
                </div>
            </section>

            <!-- Performance -->
            <section>
                <h2>‚ö° Performance Features</h2>
                
                <div class="card">
                    <h3>Compile-Time Optimization</h3>
                    <p>Veld's annotation processing happens at compile time, providing several performance benefits:</p>
                    
                    <ul>
                        <li><strong>Zero Reflection Overhead:</strong> No reflection calls during runtime</li>
                        <li><strong>Generated Factory Classes:</strong> Optimized bytecode for dependency resolution</li>
                        <li><strong>Type Safety:</strong> Compile-time error detection</li>
                        <li><strong>Fast Startup:</strong> No runtime configuration parsing</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>Memory Efficiency</h3>
                    <p>Veld's design minimizes memory usage:</p>
                    
                    <ul>
                        <li><strong>No Runtime Metadata:</strong> No annotation metadata stored at runtime</li>
                        <li><strong>Efficient Caching:</strong> Intelligent caching of component information</li>
                        <li><strong>Minimal Footprint:</strong> Small runtime library size</li>
                        <li><strong>Lazy Loading:</strong> Components created only when needed</li>
                    </ul>
                </div>
            </section>

            <!-- Next Steps -->
            <section>
                <h2>üéØ Next Steps</h2>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <div class="feature-icon">üéØ</div>
                        <h3>AOP Framework</h3>
                        <p>Learn about Veld's powerful aspect-oriented programming capabilities</p>
                        <a href="aop.html" class="btn btn-primary" style="margin-top: 1rem;">Learn AOP</a>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon">üì°</div>
                        <h3>EventBus</h3>
                        <p>Explore the publish/subscribe event system for loose coupling</p>
                        <a href="eventbus.html" class="btn btn-primary" style="margin-top: 1rem;">Learn EventBus</a>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon">‚ö°</div>
                        <h3>Performance</h3>
                        <p>See how Veld achieves 42,865x speedup over traditional DI frameworks</p>
                        <a href="optimizations.html" class="btn btn-primary" style="margin-top: 1rem;">View Benchmarks</a>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <!-- Scroll to Top Button -->
    <button id="scroll-to-top" class="scroll-to-top" onclick="scrollToTop()">‚Üë</button>

    <!-- Scripts -->
    <script src="js/main.js"></script>
</body>
</html>