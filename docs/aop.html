<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aspect-Oriented Programming - Veld DI Framework</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <a href="index.html" class="logo">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;">
                        <path d="M12 2L2 7v10c0 5.55 3.84 9.74 9 11 5.16-1.26 9-5.45 9-11V7l-10-5z"/>
                    </svg>
                    Veld
                </a>
                
                <nav>
                    <ul class="nav-menu">
                        <li><a href="getting-started.html">Getting Started</a></li>
                        <li><a href="annotations.html">Annotations</a></li>
                        <li><a href="core-features.html">Core Features</a></li>
                        <li><a href="aop.html" class="active">AOP</a></li>
                        <li><a href="eventbus.html">EventBus</a></li>
                <li><a href="spring-boot.html">Spring Boot Integration</a></li>
                        <li><a href="spring-boot.html">Spring Boot</a></li>
                        <li><a href="spring-boot.html">Spring Boot</a></li>
                        <li><a href="api.html">API Reference</a></li>
                        <li><a href="examples.html">Examples</a></li>
                    </ul>
                </nav>
                
                <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">‚ò∞</button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-layout">
        <!-- Sidebar Navigation -->
        <nav class="sidebar">
            <h3>Documentation</h3>
            <ul class="sidebar-nav">
                <li><a href="index.html">Overview</a></li>
                <li><a href="getting-started.html">Getting Started</a></li>
                <li><a href="installation.html">Installation</a></li>
                <li><a href="annotations.html">Annotations Reference</a></li>
                <li><a href="core-features.html">Core Features</a></li>
                <li><a href="aop.html" class="active">Aspect-Oriented Programming</a>
                    <ul class="sub-nav">
                        <li><a href="#aspects">Aspects</a></li>
                        <li><a href="#pointcuts">Pointcuts</a></li>
                        <li><a href="#advices">Advices</a></li>
                        <li><a href="#interceptors">Interceptors</a></li>
                    </ul>
                </li>
                <li><a href="eventbus.html">EventBus</a></li>
                <li><a href="spring-boot.html">Spring Boot Integration</a></li>
                        <li><a href="spring-boot.html">Spring Boot</a></li>
                <li><a href="spring-boot.html">Spring Boot Integration</a></li>
                <li><a href="optimizations.html">Phase 1 Optimizations</a></li>
                <li><a href="api.html">API Reference</a></li>
                <li><a href="examples.html">Examples</a></li>
            </ul>
        </nav>

        <!-- Content -->
        <div class="content">
            <h1>üéØ Aspect-Oriented Programming</h1>
            
            <div class="alert alert-info">
                <strong>üîß Overview:</strong> Veld provides a powerful AOP framework built on ASM bytecode generation, offering AspectJ-like syntax with better performance and zero reflection overhead.
            </div>

            <!-- What is AOP -->
            <section>
                <h2>ü§î What is AOP?</h2>
                
                <div class="card">
                    <p>Aspect-Oriented Programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It complements Object-Oriented Programming (OOP) by providing another way to modularize applications.</p>
                    
                    <h3>Cross-Cutting Concerns</h3>
                    <p>Common cross-cutting concerns include:</p>
                    <ul>
                        <li><strong>Logging:</strong> Recording method calls and their parameters</li>
                        <li><strong>Security:</strong> Authentication and authorization checks</li>
                        <li><strong>Transaction Management:</strong> Begin/commit/rollback database transactions</li>
                        <li><strong>Performance Monitoring:</strong> Measuring method execution times</li>
                        <li><strong>Exception Handling:</strong> Centralized exception processing</li>
                        <li><strong>Caching:</strong> Automatic method result caching</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>AOP Terminology</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Term</th>
                                <th>Description</th>
                                <th>Veld Example</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Aspect</strong></td>
                                <td>A class containing advice and pointcuts</td>
                                <td><code>@Aspect public class LoggingAspect</code></td>
                            </tr>
                            <tr>
                                <td><strong>Join Point</strong></td>
                                <td>A specific point in program execution</td>
                                <td>Method call, field access, exception throw</td>
                            </tr>
                            <tr>
                                <td><strong>Pointcut</strong></td>
                                <td>Expression that selects join points</td>
                                <td><code>execution(* com.example.service.*.*(..))</code></td>
                            </tr>
                            <tr>
                                <td><strong>Advice</strong></td>
                                <td>Action taken at a join point</td>
                                <td><code>@Before, @After, @Around</code></td>
                            </tr>
                            <tr>
                                <td><strong>Weaving</strong></td>
                                <td>Applying aspects to target code</td>
                                <td>Compile-time bytecode generation</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- Creating Aspects -->
            <section id="aspects">
                <h2>üèóÔ∏è Creating Aspects</h2>
                
                <div class="card">
                    <h3>Basic Aspect Structure</h3>
                    <p>An aspect is a class annotated with <code>@Aspect</code> that contains pointcut definitions and advice methods:</p>
                    
<pre><code>@Aspect
@Component
public class LoggingAspect {
    
    // Pointcut definition
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    
    // Advice method
    @Before("serviceMethods()")
    public void logMethodEntry(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        
        System.out.println("Entering " + methodName + " with args: " + Arrays.toString(args));
    }
    
    @After("serviceMethods()")
    public void logMethodExit(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println("Exiting " + methodName);
    }
}</code></pre>
                </div>

                <div class="card">
                    <h3>Aspect with @Component</h3>
                    <p>Aspects can be regular components, allowing dependency injection and configuration:</p>
                    
<pre><code>@Aspect
@Component
@Singleton
public class SecurityAspect {
    
    @Inject
    private SecurityManager securityManager;
    
    @Inject
    private AuditLogger auditLogger;
    
    @Pointcut("execution(* com.example.controller.*.*(..))")
    public void controllerMethods() {}
    
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    
    @Before("controllerMethods() || serviceMethods()")
    public void checkSecurity(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String userId = securityManager.getCurrentUserId();
        
        if (!securityManager.hasPermission(userId, methodName)) {
            auditLogger.logUnauthorizedAccess(userId, methodName);
            throw new SecurityException("Access denied for method: " + methodName);
        }
        
        auditLogger.logAuthorizedAccess(userId, methodName);
    }
}</code></pre>
                </div>
            </section>

            <!-- Pointcuts -->
            <section id="pointcuts">
                <h2>üéØ Pointcut Expressions</h2>
                
                <div class="card">
                    <h3>Method Execution Pointcuts</h3>
                    <p>Select methods based on execution patterns:</p>
                    
<pre><code>@Aspect
@Component
public class MethodExecutionPointcuts {
    
    // All methods in a package
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceLayer() {}
    
    // All methods with specific return type
    @Pointcut("execution(public java.util.List&lt;?&gt; com.example.repository.*.*(..))")
    public void listReturningMethods() {}
    
    // Methods with specific parameters
    @Pointcut("execution(* com.example.service.*.*(java.lang.String, ..))")
    public void stringFirstParamMethods() {}
    
    // Methods with specific annotation
    @Pointcut("execution(@Transactional * *(..))")
    public void transactionalMethods() {}
    
    // Combination of pointcuts
    @Pointcut("serviceLayer() && !listReturningMethods()")
    public void nonListServiceMethods() {}
}</code></pre>

                    <h4>Pointcut Expression Syntax</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Pattern</th>
                                <th>Description</th>
                                <th>Example</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>execution(modifiers? ret-type-declaring-type? name(param) throws?)</code></td>
                                <td>Method execution</td>
                                <td><code>execution(* com.example.Service.*(..))</code></td>
                            </tr>
                            <tr>
                                <td><code>within(type-pattern)</code></td>
                                <td>Within specific type</td>
                                <td><code>within(com.example.service.*)</code></td>
                            </tr>
                            <tr>
                                <td><code>this(type)</code></td>
                                <td>Bean of given type</td>
                                <td><code>this(com.example.Service)</code></td>
                            </tr>
                            <tr>
                                <td><code>target(type)</code></td>
                                <td>Target object of given type</td>
                                <td><code>target(com.example.Service)</code></td>
                            </tr>
                            <tr>
                                <td><code>@target(annotation-type)</code></td>
                                <td>Target has annotation</td>
                                <td><code>@target(@Component)</code></td>
                            </tr>
                            <tr>
                                <td><code>@within(annotation-type)</code></td>
                                <td>Within class with annotation</td>
                                <td><code>@within(@Service)</code></td>
                            </tr>
                            <tr>
                                <td><code>@annotation(annotation-type)</code></td>
                                <td>Method has annotation</td>
                                <td><code>@annotation(@Transactional)</code></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="card">
                    <h3>Advanced Pointcuts</h3>
                    
<pre><code>@Aspect
@Component
public class AdvancedPointcuts {
    
    // Constructor execution
    @Pointcut("execution(com.example.model.*.new(..))")
    public void constructorExecution() {}
    
    // Field access
    @Pointcut("get(* com.example.model.User.*)")
    public void userFieldGetters() {}
    
    @Pointcut("set(* com.example.model.User.*)")
    public void userFieldSetters() {}
    
    // Exception handling
    @Pointcut("handler(Exception+)")
    public void exceptionHandling() {}
    
    // Method arguments with specific types
    @Pointcut("execution(* *(..)) && args(java.io.Serializable)")
    public void serializableArgumentMethods() {}
    
    // Methods in classes with specific annotation
    @Pointcut("execution(* (@org.springframework.stereotype.Service *).*(..))")
    public void springServiceMethods() {}
}</code></pre>
                </div>
            </section>

            <!-- Advice Types -->
            <section id="advices">
                <h2>üí° Advice Types</h2>
                
                <div class="card">
                    <h3>@Before Advice</h3>
                    <p>Execute before the join point:</p>
                    
<pre><code>@Aspect
@Component
public class ValidationAspect {
    
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    
    @Before("serviceMethods()")
    public void validateArguments(JoinPoint joinPoint) {
        Object[] args = joinPoint.getArgs();
        String methodName = joinPoint.getSignature().getName();
        
        // Validate input parameters
        for (Object arg : args) {
            if (arg == null) {
                throw new IllegalArgumentException("Null argument not allowed in " + methodName);
            }
        }
        
        System.out.println("Arguments validated for " + methodName);
    }
    
    // Access join point details
    @Before("serviceMethods()")
    public void logMethodDetails(JoinPoint joinPoint) {
        System.out.println("Method: " + joinPoint.getSignature());
        System.out.println("Target: " + joinPoint.getTarget());
        System.out.println("This: " + joinPoint.getThis());
        System.out.println("Args: " + Arrays.toString(joinPoint.getArgs()));
    }
}</code></pre>
                </div>

                <div class="card">
                    <h3>@After Advice</h3>
                    <p>Execute after the join point (regardless of outcome):</p>
                    
<pre><code>@Aspect
@Component
public class CleanupAspect {
    
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    
    @After("serviceMethods()")
    public void cleanupResources(JoinPoint joinPoint) {
        System.out.println("Cleaning up resources after " + joinPoint.getSignature().getName());
        // Perform cleanup operations
    }
    
    // Access return value (for @AfterReturning)
    @AfterReturning(pointcut = "serviceMethods()", returning = "result")
    public void logSuccess(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(methodName + " completed successfully with result: " + result);
    }
    
    // Access exception (for @AfterThrowing)
    @AfterThrowing(pointcut = "serviceMethods()", throwing = "ex")
    public void logException(JoinPoint joinPoint, Exception ex) {
        String methodName = joinPoint.getSignature().getName();
        System.err.println(methodName + " failed with exception: " + ex.getMessage());
        // Log exception details, send alerts, etc.
    }
}</code></pre>
                </div>

                <div class="card">
                    <h3>@Around Advice</h3>
                    <p>Surround the join point execution (most powerful advice type):</p>
                    
<pre><code>@Aspect
@Component
public class TransactionAspect {
    
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    
    @Around("serviceMethods()")
    public Object manageTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        
        // Start transaction
        System.out.println("Starting transaction for " + methodName);
        TransactionManager.beginTransaction();
        
        try {
            // Proceed with original method execution
            Object result = joinPoint.proceed();
            
            // Commit transaction
            TransactionManager.commitTransaction();
            System.out.println("Transaction committed for " + methodName);
            
            return result;
            
        } catch (Exception e) {
            // Rollback transaction
            TransactionManager.rollbackTransaction();
            System.out.println("Transaction rolled back for " + methodName);
            
            // Log exception
            System.err.println("Method " + methodName + " failed: " + e.getMessage());
            
            // Re-throw or handle exception
            throw e;
        }
    }
}</code></pre>

                    <h4>ProceedingJoinPoint Methods</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Method</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>proceed()</code></td>
                                <td>Proceed with the original method execution</td>
                            </tr>
                            <tr>
                                <td><code>proceed(Object[] args)</code></td>
                                <td>Proceed with modified arguments</td>
                            </tr>
                            <tr>
                                <td><code>getArgs()</code></td>
                                <td>Get method arguments</td>
                            </tr>
                            <tr>
                                <td><code>getSignature()</code></td>
                                <td>Get method signature</td>
                            </tr>
                            <tr>
                                <td><code>getTarget()</code></td>
                                <td>Get target object</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="card">
                    <h3>Performance Monitoring Aspect</h3>
                    <p>Complete example of monitoring method execution time:</p>
                    
<pre><code>@Aspect
@Component
@Singleton
public class PerformanceMonitoringAspect {
    
    private final Map&lt;String, MethodStats&gt; methodStats = new ConcurrentHashMap&lt;&gt;();
    
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    
    @Around("serviceMethods()")
    public Object monitorPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().toShortString();
        long startTime = System.nanoTime();
        
        try {
            Object result = joinPoint.proceed();
            return result;
        } finally {
            long endTime = System.nanoTime();
            long duration = endTime - startTime;
            
            updateStats(methodName, duration);
        }
    }
    
    private void updateStats(String methodName, long duration) {
        methodStats.compute(methodName, (key, existing) -&gt; {
            if (existing == null) {
                return new MethodStats(duration, duration, duration, 1);
            }
            
            return new MethodStats(
                Math.min(existing.getMin(), duration),
                Math.max(existing.getMax(), duration),
                existing.getTotal() + duration,
                existing.getCount() + 1
            );
        });
    }
    
    public Map&lt;String, MethodStats&gt; getStats() {
        return Collections.unmodifiableMap(methodStats);
    }
    
    public static class MethodStats {
        private final long min;
        private final long max;
        private final long total;
        private final long count;
        
        public MethodStats(long min, long max, long total, long count) {
            this.min = min;
            this.max = max;
            this.total = total;
            this.count = count;
        }
        
        public double getAverage() {
            return count &gt; 0 ? (double) total / count : 0;
        }
        
        // Getters
        public long getMin() { return min; }
        public long getMax() { return max; }
        public long getTotal() { return total; }
        public long getCount() { return count; }
    }
}</code></pre>
                </div>
            </section>

            <!-- Interceptors -->
            <section id="interceptors">
                <h2>üîå CDI Interceptors</h2>
                
                <div class="card">
                    <h3>What are Interceptors?</h3>
                    <p>Interceptors are a CDI (Contexts and Dependency Injection) mechanism for intercepting method invocations. Veld provides full support for CDI interceptors:</p>
                    
                    <h4>Benefits of Interceptors</h4>
                    <ul>
                        <li><strong>Standard Compliance:</strong> Follows Jakarta EE interceptor specification</li>
                        <li><strong>Declarative:</strong> Use annotations to mark intercepted methods</li>
                        <li><strong>Portable:</strong> Works across different CDI implementations</li>
                        <li><strong>Flexible:</strong> Can be enabled/disabled globally</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>Creating an Interceptor</h3>
                    
<pre><code>// Define interceptor binding annotation
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@InterceptorBinding
public @interface Timing {
    // No parameters needed
}

// Create the interceptor
@Interceptor
@Component
@Timing
public class TimingInterceptor {
    
    @AroundInvoke
    public Object measureExecutionTime(InvocationContext context) throws Exception {
        String methodName = context.getMethod().getName();
        long startTime = System.currentTimeMillis();
        
        try {
            return context.proceed();
        } finally {
            long duration = System.currentTimeMillis() - startTime;
            System.out.println("Method " + methodName + " executed in " + duration + "ms");
        }
    }
}</code></pre>

                    <h4>Using the Interceptor</h4>
                    
<pre><code>@Component
@Singleton
public class UserService {
    
    @Timing
    public User createUser(String name, String email) {
        // This method will be intercepted by TimingInterceptor
        User user = new User(name, email);
        return userRepository.save(user);
    }
    
    @Timing
    public List&lt;User&gt; findAllUsers() {
        // This method will also be intercepted
        return userRepository.findAll();
    }
}</code></pre>
                </div>

                <div class="card">
                    <h3>Built-in Interceptors</h3>
                    <p>Veld includes several built-in interceptors for common cross-cutting concerns:</p>
                    
                    <h4>Logging Interceptor</h4>
                    
<pre><code>@Interceptor
@Component
@Logging
public class LoggingInterceptor {
    
    @AroundInvoke
    public Object logMethodCall(InvocationContext context) throws Exception {
        String className = context.getMethod().getDeclaringClass().getSimpleName();
        String methodName = context.getMethod().getName();
        
        // Log entry
        System.out.println("Entering " + className + "." + methodName);
        
        try {
            Object result = context.proceed();
            
            // Log successful exit
            System.out.println("Exiting " + className + "." + methodName + " successfully");
            
            return result;
        } catch (Exception e) {
            // Log exception
            System.err.println("Exception in " + className + "." + methodName + ": " + e.getMessage());
            throw e;
        }
    }
}</code></pre>

                    <h4>Validation Interceptor</h4>
                    
<pre><code>@Interceptor
@Component
@Validation
public class ValidationInterceptor {
    
    @AroundInvoke
    public Object validateArguments(InvocationContext context) throws Exception {
        Object[] parameters = context.getParameters();
        
        // Validate each parameter
        for (Object parameter : parameters) {
            if (parameter == null) {
                throw new IllegalArgumentException("Null parameter not allowed");
            }
            
            if (parameter instanceof String) {
                String str = (String) parameter;
                if (str.trim().isEmpty()) {
                    throw new IllegalArgumentException("Empty string not allowed");
                }
            }
        }
        
        return context.proceed();
    }
}</code></pre>
                </div>

                <div class="card">
                    <h3>Interceptor Configuration</h3>
                    <p>Configure interceptor ordering and enable/disable behavior:</p>
                    
<pre><code># Enable/disable specific interceptors
veld.interceptor.logging.enabled=true
veld.interceptor.timing.enabled=true
veld.interceptor.validation.enabled=false

# Set interceptor order (lower number = higher priority)
veld.interceptor.logging.order=1
veld.interceptor.timing.order=2
veld.interceptor.validation.order=3</code></pre>
                </div>
            </section>

            <!-- Advanced AOP -->
            <section>
                <h2>üöÄ Advanced AOP Features</h2>
                
                <div class="card">
                    <h3>Custom Pointcut Expressions</h3>
                    <p>Create reusable pointcut definitions:</p>
                    
<pre><code>@Aspect
@Component
public class CustomPointcuts {
    
    // Define reusable pointcuts
    @Pointcut("execution(* com.example.repository.*Repository.*(..))")
    public void repositoryMethods() {}
    
    @Pointcut("execution(* com.example.service.*Service.*(..))")
    public void serviceMethods() {}
    
    @Pointcut("execution(* (@org.springframework.stereotype.Service *).*(..))")
    public void springServiceMethods() {}
    
    @Pointcut("@annotation(org.springframework.transaction.annotation.Transactional)")
    public void transactionalMethods() {}
    
    @Pointcut("repositoryMethods() || serviceMethods()")
    public void dataAccessLayer() {}
    
    @Pointcut("dataAccessLayer() && transactionalMethods()")
    public void transactionalDataAccess() {}
}</code></pre>
                </div>

                <div class="card">
                    <h3>Aspect Ordering</h3>
                    <p>Control the order in which aspects are applied:</p>
                    
<pre><code>@Aspect
@Component
@Order(1)  // Applied first
public class SecurityAspect {
    @Before("serviceMethods()")
    public void checkSecurity() {
        // Security check runs first
    }
}

@Aspect
@Component
@Order(2)  // Applied second
public class LoggingAspect {
    @Before("serviceMethods()")
    public void logMethodCall() {
        // Logging runs after security check
    }
}</code></pre>
                </div>

                <div class="card">
                    <h3>Conditional Aspects</h3>
                    <p>Enable aspects based on configuration:</p>
                    
<pre><code>@Aspect
@Component
@ConditionalOnProperty(name = "app.aop.logging.enabled", havingValue = "true")
public class ConditionalLoggingAspect {
    
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    
    @Before("serviceMethods()")
    public void conditionalLog(JoinPoint joinPoint) {
        if (isDebugEnabled()) {
            System.out.println("DEBUG: " + joinPoint.getSignature());
        }
    }
    
    private boolean isDebugEnabled() {
        // Check configuration
        return true;
    }
}</code></pre>
                </div>
            </section>

            <!-- Best Practices -->
            <section>
                <h2>üí° Best Practices</h2>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <div class="feature-icon">üéØ</div>
                        <h3>Keep Aspects Simple</h3>
                        <p>Each aspect should focus on a single cross-cutting concern. Don't mix logging, security, and transaction management in one aspect.</p>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon">‚ö°</div>
                        <h3>Use Appropriate Pointcuts</h3>
                        <p>Be specific with pointcut expressions to avoid unnecessary interception and performance overhead.</p>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon">üîí</div>
                        <h3>Handle Exceptions Properly</h3>
                        <p>Always handle exceptions in @Around advice to prevent unexpected behavior and resource leaks.</p>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon">üìä</div>
                        <h3>Monitor Performance</h3>
                        <p>Be aware of the performance impact of aspects. Use @Around advice sparingly and optimize pointcuts.</p>
                    </div>
                </div>

                <div class="card">
                    <h3>Common Patterns</h3>
                    
                    <h4>Caching Aspect</h4>
                    
<pre><code>@Aspect
@Component
public class CacheAspect {
    
    private final Cache cache;
    
    @Inject
    public CacheAspect(Cache cache) {
        this.cache = cache;
    }
    
    @Pointcut("@annotation(Cached)")
    public void cachedMethods() {}
    
    @Around("cachedMethods()")
    public Object cacheResult(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        String cacheKey = generateCacheKey(signature, joinPoint.getArgs());
        
        // Check cache first
        Object cached = cache.get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        // Execute method and cache result
        Object result = joinPoint.proceed();
        cache.put(cacheKey, result);
        
        return result;
    }
}</code></pre>

                    <h4>Retry Aspect</h4>
                    
<pre><code>@Aspect
@Component
public class RetryAspect {
    
    @Pointcut("@annotation(Retryable)")
    public void retryableMethods() {}
    
    @Around("retryableMethods()")
    public Object retryOperation(ProceedingJoinPoint joinPoint) throws Throwable {
        Retryable retryable = joinPoint.getSignature()
            .getDeclaringType()
            .getMethod(joinPoint.getSignature().getName())
            .getAnnotation(Retryable.class);
        
        int maxAttempts = retryable.maxAttempts();
        long delayMs = retryable.delayMs();
        
        for (int attempt = 1; attempt &lt;= maxAttempts; attempt++) {
            try {
                return joinPoint.proceed();
            } catch (Exception e) {
                if (attempt == maxAttempts) {
                    throw e;
                }
                
                if (!isRetryableException(e)) {
                    throw e;
                }
                
                Thread.sleep(delayMs);
            }
        }
        
        throw new IllegalStateException("Should not reach here");
    }
}</code></pre>
                </div>
            </section>

            <!-- Next Steps -->
            <section>
                <h2>üéØ Next Steps</h2>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <div class="feature-icon">üì°</div>
                        <h3>EventBus</h3>
                        <p>Learn about Veld's event system for loose coupling between components</p>
                        <a href="eventbus.html" class="btn btn-primary" style="margin-top: 1rem;">Learn EventBus</a>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon">‚ö°</div>
                        <h3>Performance</h3>
                        <p>See how Veld's AOP framework achieves better performance than traditional solutions</p>
                        <a href="optimizations.html" class="btn btn-primary" style="margin-top: 1rem;">View Performance</a>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon">üéØ</div>
                        <h3>Examples</h3>
                        <p>Explore practical AOP examples and real-world use cases</p>
                        <a href="examples.html" class="btn btn-primary" style="margin-top: 1rem;">View Examples</a>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <!-- Scroll to Top Button -->
    <button id="scroll-to-top" class="scroll-to-top" onclick="scrollToTop()">‚Üë</button>

    <!-- Scripts -->
    <script src="js/main.js"></script>
</body>
</html>