/*
 * Copyright 2025 Veld Framework
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.yasmramos.veld.processor;

import io.github.yasmramos.veld.runtime.Scope;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for {@link ComponentFactoryGenerator} bytecode generation.
 * Uses ASM ClassReader to inspect generated bytecode without loading classes.
 */
@DisplayName("ComponentFactoryGenerator Tests")
class ComponentFactoryGeneratorTest {

    /**
     * Parses bytecode into a ClassNode for inspection.
     */
    private ClassNode parseClass(byte[] bytecode) {
        ClassReader cr = new ClassReader(bytecode);
        ClassNode cn = new ClassNode();
        cr.accept(cn, 0);
        return cn;
    }

    /**
     * Gets method names from a ClassNode.
     */
    private List<String> getMethodNames(ClassNode cn) {
        return cn.methods.stream()
            .map(m -> m.name)
            .collect(Collectors.toList());
    }

    /**
     * Checks if a method exists in the ClassNode.
     */
    private boolean hasMethod(ClassNode cn, String methodName) {
        return cn.methods.stream().anyMatch(m -> m.name.equals(methodName));
    }

    /**
     * Gets a method by name from ClassNode.
     */
    private MethodNode getMethod(ClassNode cn, String methodName) {
        return cn.methods.stream()
            .filter(m -> m.name.equals(methodName))
            .findFirst()
            .orElse(null);
    }

    @Nested
    @DisplayName("Basic Factory Generation")
    class BasicFactoryGenerationTests {

        @Test
        @DisplayName("should generate valid bytecode for simple component")
        void shouldGenerateValidBytecodeForSimpleComponent() {
            ComponentInfo component = new ComponentInfo(
                "com.example.SimpleService",
                "simpleService",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            assertNotNull(bytecode);
            assertTrue(bytecode.length > 0);
        }

        @Test
        @DisplayName("should generate factory with correct class name")
        void shouldGenerateFactoryWithCorrectClassName() {
            ComponentInfo component = new ComponentInfo(
                "com.example.MyService",
                "myService",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertEquals("com/example/MyService$$VeldFactory", cn.name);
        }

        @Test
        @DisplayName("should generate public final class")
        void shouldGeneratePublicFinalClass() {
            ComponentInfo component = new ComponentInfo(
                "com.example.TestComponent",
                "testComponent",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            
            assertTrue((cn.access & Opcodes.ACC_PUBLIC) != 0, "Should be public");
            assertTrue((cn.access & Opcodes.ACC_FINAL) != 0, "Should be final");
        }

        @Test
        @DisplayName("should extend Object")
        void shouldExtendObject() {
            ComponentInfo component = new ComponentInfo(
                "com.example.ServiceImpl",
                "serviceImpl",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertEquals("java/lang/Object", cn.superName);
        }

        @Test
        @DisplayName("should implement ComponentFactory interface")
        void shouldImplementComponentFactoryInterface() {
            ComponentInfo component = new ComponentInfo(
                "com.example.ServiceImpl",
                "serviceImpl",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(cn.interfaces.contains("io/github/yasmramos/veld/runtime/ComponentFactory"));
        }
    }

    @Nested
    @DisplayName("Scope Generation")
    class ScopeGenerationTests {

        @Test
        @DisplayName("should generate singleton scope factory")
        void shouldGenerateSingletonScopeFactory() {
            ComponentInfo component = new ComponentInfo(
                "com.example.SingletonService",
                "singletonService",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "getScope"));
        }

        @Test
        @DisplayName("should generate prototype scope factory")
        void shouldGeneratePrototypeScopeFactory() {
            ComponentInfo component = new ComponentInfo(
                "com.example.PrototypeService",
                "prototypeService",
                Scope.PROTOTYPE
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "getScope"));
        }
    }

    @Nested
    @DisplayName("Method Generation")
    class MethodGenerationTests {

        @Test
        @DisplayName("should generate default constructor")
        void shouldGenerateDefaultConstructor() {
            ComponentInfo component = new ComponentInfo(
                "com.example.ConstructorTest",
                "constructorTest",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "<init>"));
            
            MethodNode initMethod = getMethod(cn, "<init>");
            assertNotNull(initMethod);
            assertEquals("()V", initMethod.desc);
        }

        @Test
        @DisplayName("should generate getComponentType method")
        void shouldGenerateGetComponentTypeMethod() {
            ComponentInfo component = new ComponentInfo(
                "com.example.TypeTest",
                "typeTest",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "getComponentType"));
            
            MethodNode method = getMethod(cn, "getComponentType");
            assertNotNull(method);
            assertEquals("()Ljava/lang/Class;", method.desc);
        }

        @Test
        @DisplayName("should generate getComponentName method")
        void shouldGenerateGetComponentNameMethod() {
            ComponentInfo component = new ComponentInfo(
                "com.example.NameTest",
                "nameTest",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "getComponentName"));
            
            MethodNode method = getMethod(cn, "getComponentName");
            assertNotNull(method);
            assertEquals("()Ljava/lang/String;", method.desc);
        }

        @Test
        @DisplayName("should generate getScope method")
        void shouldGenerateGetScopeMethod() {
            ComponentInfo component = new ComponentInfo(
                "com.example.ScopeTest",
                "scopeTest",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "getScope"));
            
            MethodNode method = getMethod(cn, "getScope");
            assertNotNull(method);
            assertEquals("()Lio/github/yasmramos/veld/runtime/Scope;", method.desc);
        }

        @Test
        @DisplayName("should generate create method")
        void shouldGenerateCreateMethod() {
            ComponentInfo component = new ComponentInfo(
                "com.example.CreateTest",
                "createTest",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "create"));
        }

        @Test
        @DisplayName("should generate invokePostConstruct method")
        void shouldGenerateInvokePostConstructMethod() {
            ComponentInfo component = new ComponentInfo(
                "com.example.LifecycleTest",
                "lifecycleTest",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "invokePostConstruct"));
        }

        @Test
        @DisplayName("should generate invokePreDestroy method")
        void shouldGenerateInvokePreDestroyMethod() {
            ComponentInfo component = new ComponentInfo(
                "com.example.DestroyTest",
                "destroyTest",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "invokePreDestroy"));
        }

        @Test
        @DisplayName("should generate all required ComponentFactory methods")
        void shouldGenerateAllRequiredComponentFactoryMethods() {
            ComponentInfo component = new ComponentInfo(
                "com.example.CompleteTest",
                "completeTest",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            List<String> methods = getMethodNames(cn);
            
            assertTrue(methods.contains("<init>"), "Should have constructor");
            assertTrue(methods.contains("create"), "Should have create");
            assertTrue(methods.contains("getComponentType"), "Should have getComponentType");
            assertTrue(methods.contains("getComponentName"), "Should have getComponentName");
            assertTrue(methods.contains("getScope"), "Should have getScope");
            assertTrue(methods.contains("invokePostConstruct"), "Should have invokePostConstruct");
            assertTrue(methods.contains("invokePreDestroy"), "Should have invokePreDestroy");
        }
    }

    @Nested
    @DisplayName("Lazy Component Generation")
    class LazyComponentGenerationTests {

        @Test
        @DisplayName("should generate isLazy method for lazy components")
        void shouldGenerateIsLazyMethodForLazyComponents() {
            ComponentInfo component = new ComponentInfo(
                "com.example.LazyService",
                "lazyService",
                Scope.SINGLETON,
                true  // lazy = true
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "isLazy"));
            
            MethodNode method = getMethod(cn, "isLazy");
            assertNotNull(method);
            assertEquals("()Z", method.desc);  // returns boolean
        }

        @Test
        @DisplayName("should not generate isLazy method for non-lazy components")
        void shouldNotGenerateIsLazyMethodForNonLazyComponents() {
            ComponentInfo component = new ComponentInfo(
                "com.example.EagerService",
                "eagerService",
                Scope.SINGLETON,
                false  // lazy = false
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertFalse(hasMethod(cn, "isLazy"));
        }
    }

    @Nested
    @DisplayName("Conditional Component Generation")
    class ConditionalComponentGenerationTests {

        @Test
        @DisplayName("should generate hasConditions method for conditional components")
        void shouldGenerateHasConditionsMethodForConditionalComponents() {
            ComponentInfo component = new ComponentInfo(
                "com.example.ConditionalService",
                "conditionalService",
                Scope.SINGLETON
            );
            ConditionInfo conditions = new ConditionInfo();
            conditions.addPropertyCondition("feature.enabled", "true", false);
            component.setConditionInfo(conditions);
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "hasConditions"));
            
            MethodNode method = getMethod(cn, "hasConditions");
            assertNotNull(method);
            assertEquals("()Z", method.desc);  // returns boolean
        }

        @Test
        @DisplayName("should generate evaluateConditions method for conditional components")
        void shouldGenerateEvaluateConditionsMethod() {
            ComponentInfo component = new ComponentInfo(
                "com.example.EvalCondService",
                "evalCondService",
                Scope.SINGLETON
            );
            ConditionInfo conditions = new ConditionInfo();
            conditions.addProfileCondition(Arrays.asList("dev", "test"));
            component.setConditionInfo(conditions);
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "evaluateConditions"));
        }

        @Test
        @DisplayName("should generate createConditionEvaluator method for conditional components")
        void shouldGenerateCreateConditionEvaluatorMethod() {
            ComponentInfo component = new ComponentInfo(
                "com.example.CondEvalService",
                "condEvalService",
                Scope.SINGLETON
            );
            ConditionInfo conditions = new ConditionInfo();
            conditions.addClassCondition(Arrays.asList("com.optional.Library"));
            component.setConditionInfo(conditions);
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "createConditionEvaluator"));
        }

        @Test
        @DisplayName("should not generate condition methods for unconditional components")
        void shouldNotGenerateConditionMethodsForUnconditionalComponents() {
            ComponentInfo component = new ComponentInfo(
                "com.example.UnconditionalService",
                "unconditionalService",
                Scope.SINGLETON
            );
            // No conditions added
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertFalse(hasMethod(cn, "hasConditions"));
            assertFalse(hasMethod(cn, "evaluateConditions"));
            assertFalse(hasMethod(cn, "createConditionEvaluator"));
        }

        @Test
        @DisplayName("should generate condition methods for missing bean conditions")
        void shouldGenerateConditionMethodsForMissingBeanConditions() {
            ComponentInfo component = new ComponentInfo(
                "com.example.MissingBeanService",
                "missingBeanService",
                Scope.SINGLETON
            );
            ConditionInfo conditions = new ConditionInfo();
            conditions.addMissingBeanTypeCondition(Arrays.asList("com.example.OtherService"));
            component.setConditionInfo(conditions);
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "hasConditions"));
            assertTrue(hasMethod(cn, "evaluateConditions"));
        }
    }

    @Nested
    @DisplayName("Interface Implementation Generation")
    class InterfaceImplementationGenerationTests {

        @Test
        @DisplayName("should generate getImplementedInterfaces for components with interfaces")
        void shouldGenerateGetImplementedInterfacesForComponentsWithInterfaces() {
            ComponentInfo component = new ComponentInfo(
                "com.example.ServiceImpl",
                "serviceImpl",
                Scope.SINGLETON
            );
            component.addImplementedInterface("com.example.Service");
            component.addImplementedInterface("com.example.OtherService");
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertTrue(hasMethod(cn, "getImplementedInterfaces"));
        }

        @Test
        @DisplayName("should not generate getImplementedInterfaces for components without interfaces")
        void shouldNotGenerateGetImplementedInterfacesForComponentsWithoutInterfaces() {
            ComponentInfo component = new ComponentInfo(
                "com.example.StandaloneService",
                "standaloneService",
                Scope.SINGLETON
            );
            // No interfaces
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            assertFalse(hasMethod(cn, "getImplementedInterfaces"));
        }
    }

    @Nested
    @DisplayName("Bridge Methods Generation")
    class BridgeMethodsGenerationTests {

        @Test
        @DisplayName("should generate bridge methods for type erasure")
        void shouldGenerateBridgeMethodsForTypeErasure() {
            ComponentInfo component = new ComponentInfo(
                "com.example.GenericService",
                "genericService",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            
            // Count create methods (should have bridge + typed version)
            long createMethodCount = cn.methods.stream()
                .filter(m -> m.name.equals("create"))
                .count();
            
            // Should have at least 2 (typed return + bridge with Object return)
            assertTrue(createMethodCount >= 2, "Should have bridge methods");
        }

        @Test
        @DisplayName("bridge methods should have synthetic and bridge flags")
        void bridgeMethodsShouldHaveSyntheticAndBridgeFlags() {
            ComponentInfo component = new ComponentInfo(
                "com.example.BridgeTest",
                "bridgeTest",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            ClassNode cn = parseClass(bytecode);
            
            // Find bridge methods (return Object instead of specific type)
            List<MethodNode> bridgeMethods = cn.methods.stream()
                .filter(m -> m.name.equals("create") && m.desc.contains("Ljava/lang/Object;"))
                .collect(Collectors.toList());
            
            assertFalse(bridgeMethods.isEmpty(), "Should have bridge create method");
            
            for (MethodNode bridge : bridgeMethods) {
                assertTrue((bridge.access & Opcodes.ACC_BRIDGE) != 0, 
                    "Bridge method should have ACC_BRIDGE flag");
            }
        }
    }

    @Nested
    @DisplayName("Bytecode Size Tests")
    class BytecodeSizeTests {

        @Test
        @DisplayName("should generate reasonable bytecode size for simple component")
        void shouldGenerateReasonableBytecodeSize() {
            ComponentInfo component = new ComponentInfo(
                "com.example.SimpleComponent",
                "simpleComponent",
                Scope.SINGLETON
            );
            
            ComponentFactoryGenerator generator = new ComponentFactoryGenerator(component);
            byte[] bytecode = generator.generate();
            
            // Should be between 500 bytes and 10KB for a simple factory
            assertTrue(bytecode.length > 500, "Bytecode too small");
            assertTrue(bytecode.length < 10000, "Bytecode too large");
        }

        @Test
        @DisplayName("conditional component should have larger bytecode")
        void conditionalComponentShouldHaveLargerBytecode() {
            ComponentInfo simple = new ComponentInfo(
                "com.example.Simple",
                "simple",
                Scope.SINGLETON
            );
            
            ComponentInfo conditional = new ComponentInfo(
                "com.example.Conditional",
                "conditional",
                Scope.SINGLETON
            );
            ConditionInfo conditions = new ConditionInfo();
            conditions.addPropertyCondition("prop", "val", false);
            conditions.addProfileCondition(Arrays.asList("dev"));
            conditions.addClassCondition(Arrays.asList("com.optional.Lib"));
            conditional.setConditionInfo(conditions);
            
            byte[] simpleBytecode = new ComponentFactoryGenerator(simple).generate();
            byte[] conditionalBytecode = new ComponentFactoryGenerator(conditional).generate();
            
            assertTrue(conditionalBytecode.length > simpleBytecode.length,
                "Conditional component should have more bytecode");
        }
    }
}
