/*
 * Copyright 2025 Veld Framework
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.yasmramos.processor;

import io.github.yasmramos.runtime.Scope;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for {@link RegistryGenerator} bytecode generation.
 * Uses ASM ClassReader to inspect generated bytecode without loading classes.
 */
@DisplayName("RegistryGenerator Tests")
class RegistryGeneratorTest {

    /**
     * Parses bytecode into a ClassNode for inspection.
     */
    private ClassNode parseClass(byte[] bytecode) {
        ClassReader cr = new ClassReader(bytecode);
        ClassNode cn = new ClassNode();
        cr.accept(cn, 0);
        return cn;
    }

    /**
     * Gets method names from a ClassNode.
     */
    private List<String> getMethodNames(ClassNode cn) {
        return cn.methods.stream()
            .map(m -> m.name)
            .collect(Collectors.toList());
    }

    /**
     * Checks if a method exists in the ClassNode.
     */
    private boolean hasMethod(ClassNode cn, String methodName) {
        return cn.methods.stream().anyMatch(m -> m.name.equals(methodName));
    }

    /**
     * Gets a method by name from ClassNode.
     */
    private MethodNode getMethod(ClassNode cn, String methodName) {
        return cn.methods.stream()
            .filter(m -> m.name.equals(methodName))
            .findFirst()
            .orElse(null);
    }

    /**
     * Gets field names from a ClassNode.
     */
    private List<String> getFieldNames(ClassNode cn) {
        return cn.fields.stream()
            .map(f -> f.name)
            .collect(Collectors.toList());
    }

    /**
     * Checks if a field exists in the ClassNode.
     */
    private boolean hasField(ClassNode cn, String fieldName) {
        return cn.fields.stream().anyMatch(f -> f.name.equals(fieldName));
    }

    /**
     * Gets a field by name from ClassNode.
     */
    private FieldNode getField(ClassNode cn, String fieldName) {
        return cn.fields.stream()
            .filter(f -> f.name.equals(fieldName))
            .findFirst()
            .orElse(null);
    }

    @Nested
    @DisplayName("Basic Registry Generation")
    class BasicRegistryGenerationTests {

        @Test
        @DisplayName("should generate valid bytecode with empty component list")
        void shouldGenerateValidBytecodeWithEmptyComponentList() {
            List<ComponentInfo> components = new ArrayList<>();
            RegistryGenerator generator = new RegistryGenerator(components);
            
            byte[] bytecode = generator.generate();
            
            assertNotNull(bytecode);
            assertTrue(bytecode.length > 0);
        }

        @Test
        @DisplayName("should generate valid bytecode with single component")
        void shouldGenerateValidBytecodeWithSingleComponent() {
            List<ComponentInfo> components = Arrays.asList(
                new ComponentInfo("com.example.MyService", "myService", Scope.SINGLETON)
            );
            RegistryGenerator generator = new RegistryGenerator(components);
            
            byte[] bytecode = generator.generate();
            
            assertNotNull(bytecode);
            assertTrue(bytecode.length > 0);
        }

        @Test
        @DisplayName("should generate valid bytecode with multiple components")
        void shouldGenerateValidBytecodeWithMultipleComponents() {
            List<ComponentInfo> components = Arrays.asList(
                new ComponentInfo("com.example.ServiceA", "serviceA", Scope.SINGLETON),
                new ComponentInfo("com.example.ServiceB", "serviceB", Scope.PROTOTYPE),
                new ComponentInfo("com.example.ServiceC", "serviceC", Scope.SINGLETON)
            );
            RegistryGenerator generator = new RegistryGenerator(components);
            
            byte[] bytecode = generator.generate();
            
            assertNotNull(bytecode);
            assertTrue(bytecode.length > 0);
        }

        @Test
        @DisplayName("should generate registry with correct class name")
        void shouldGenerateRegistryWithCorrectClassName() {
            List<ComponentInfo> components = new ArrayList<>();
            RegistryGenerator generator = new RegistryGenerator(components);
            
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertEquals("io/github/yasmramos/VeldRegistry", cn.name);
        }

        @Test
        @DisplayName("should return correct class name")
        void shouldReturnCorrectClassName() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            
            assertEquals("io.github.yasmramos.generated.VeldRegistry", generator.getRegistryClassName());
        }

        @Test
        @DisplayName("should return correct internal name")
        void shouldReturnCorrectInternalName() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            
            assertEquals("io/github/yasmramos/VeldRegistry", generator.getRegistryInternalName());
        }
    }

    @Nested
    @DisplayName("Class Structure Generation")
    class ClassStructureGenerationTests {

        @Test
        @DisplayName("should generate public final class")
        void shouldGeneratePublicFinalClass() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue((cn.access & Opcodes.ACC_PUBLIC) != 0, "Should be public");
            assertTrue((cn.access & Opcodes.ACC_FINAL) != 0, "Should be final");
        }

        @Test
        @DisplayName("should extend Object")
        void shouldExtendObject() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertEquals("java/lang/Object", cn.superName);
        }

        @Test
        @DisplayName("should implement ComponentRegistry interface")
        void shouldImplementComponentRegistryInterface() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue(cn.interfaces.contains("com/veld/runtime/ComponentRegistry"));
        }
    }

    @Nested
    @DisplayName("Field Generation")
    class FieldGenerationTests {

        @Test
        @DisplayName("should generate factoriesByType field")
        void shouldGenerateFactoriesByTypeField() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue(hasField(cn, "factoriesByType"));
            
            FieldNode field = getField(cn, "factoriesByType");
            assertNotNull(field);
            assertEquals("Ljava/util/Map;", field.desc);
            assertTrue((field.access & Opcodes.ACC_PRIVATE) != 0);
            assertTrue((field.access & Opcodes.ACC_FINAL) != 0);
        }

        @Test
        @DisplayName("should generate factoriesByName field")
        void shouldGenerateFactoriesByNameField() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue(hasField(cn, "factoriesByName"));
            
            FieldNode field = getField(cn, "factoriesByName");
            assertNotNull(field);
            assertEquals("Ljava/util/Map;", field.desc);
            assertTrue((field.access & Opcodes.ACC_PRIVATE) != 0);
            assertTrue((field.access & Opcodes.ACC_FINAL) != 0);
        }

        @Test
        @DisplayName("should generate factories field")
        void shouldGenerateFactoriesField() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue(hasField(cn, "factories"));
            
            FieldNode field = getField(cn, "factories");
            assertNotNull(field);
            assertEquals("[Lcom/veld/runtime/ComponentFactory;", field.desc);
            assertTrue((field.access & Opcodes.ACC_PRIVATE) != 0);
            assertTrue((field.access & Opcodes.ACC_FINAL) != 0);
        }

        @Test
        @DisplayName("should generate factoriesBySupertype field")
        void shouldGenerateFactoriesBySupertypeField() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue(hasField(cn, "factoriesBySupertype"));
            
            FieldNode field = getField(cn, "factoriesBySupertype");
            assertNotNull(field);
            assertEquals("Ljava/util/Map;", field.desc);
            assertTrue((field.access & Opcodes.ACC_PRIVATE) != 0);
            assertTrue((field.access & Opcodes.ACC_FINAL) != 0);
        }

        @Test
        @DisplayName("should generate all required fields")
        void shouldGenerateAllRequiredFields() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            List<String> fieldNames = getFieldNames(cn);
            
            // Static fields for ultra-fast lookup
            assertTrue(fieldNames.contains("TYPE_INDICES"));
            assertTrue(fieldNames.contains("NAME_INDICES"));
            assertTrue(fieldNames.contains("SCOPES"));
            assertTrue(fieldNames.contains("LAZY_FLAGS"));
            assertTrue(fieldNames.contains("SUPERTYPE_INDICES"));
            // Instance fields
            assertTrue(fieldNames.contains("factories"));
            assertTrue(fieldNames.contains("factoriesByType"));
            assertTrue(fieldNames.contains("factoriesByName"));
            assertTrue(fieldNames.contains("factoriesBySupertype"));
            assertEquals(9, fieldNames.size());
        }
    }

    @Nested
    @DisplayName("Method Generation")
    class MethodGenerationTests {

        @Test
        @DisplayName("should generate constructor")
        void shouldGenerateConstructor() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue(hasMethod(cn, "<init>"));
            
            MethodNode initMethod = getMethod(cn, "<init>");
            assertNotNull(initMethod);
            assertEquals("()V", initMethod.desc);
            assertTrue((initMethod.access & Opcodes.ACC_PUBLIC) != 0);
        }

        @Test
        @DisplayName("should generate getAllFactories method")
        void shouldGenerateGetAllFactoriesMethod() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue(hasMethod(cn, "getAllFactories"));
            
            MethodNode method = getMethod(cn, "getAllFactories");
            assertNotNull(method);
            assertEquals("()Ljava/util/List;", method.desc);
            assertTrue((method.access & Opcodes.ACC_PUBLIC) != 0);
        }

        @Test
        @DisplayName("should generate getFactory method for Class type")
        void shouldGenerateGetFactoryByTypeMethod() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            // Find getFactory that takes Class parameter
            boolean hasGetFactoryByType = cn.methods.stream()
                .anyMatch(m -> m.name.equals("getFactory") 
                    && m.desc.equals("(Ljava/lang/Class;)Lcom/veld/runtime/ComponentFactory;"));
            
            assertTrue(hasGetFactoryByType, "Should have getFactory(Class) method");
        }

        @Test
        @DisplayName("should generate getFactory method for String name")
        void shouldGenerateGetFactoryByNameMethod() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            // Find getFactory that takes String parameter
            boolean hasGetFactoryByName = cn.methods.stream()
                .anyMatch(m -> m.name.equals("getFactory") 
                    && m.desc.equals("(Ljava/lang/String;)Lcom/veld/runtime/ComponentFactory;"));
            
            assertTrue(hasGetFactoryByName, "Should have getFactory(String) method");
        }

        @Test
        @DisplayName("should generate getFactoriesForType method")
        void shouldGenerateGetFactoriesForTypeMethod() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue(hasMethod(cn, "getFactoriesForType"));
            
            MethodNode method = getMethod(cn, "getFactoriesForType");
            assertNotNull(method);
            assertEquals("(Ljava/lang/Class;)Ljava/util/List;", method.desc);
            assertTrue((method.access & Opcodes.ACC_PUBLIC) != 0);
        }

        @Test
        @DisplayName("should generate all required ComponentRegistry methods")
        void shouldGenerateAllRequiredComponentRegistryMethods() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            List<String> methods = getMethodNames(cn);
            
            assertTrue(methods.contains("<init>"), "Should have constructor");
            assertTrue(methods.contains("getAllFactories"), "Should have getAllFactories");
            assertTrue(methods.contains("getFactory"), "Should have getFactory");
            assertTrue(methods.contains("getFactoriesForType"), "Should have getFactoriesForType");
        }
    }

    @Nested
    @DisplayName("Component Registration Tests")
    class ComponentRegistrationTests {

        @Test
        @DisplayName("bytecode size should increase with more components")
        void bytecodeSizeShouldIncreaseWithMoreComponents() {
            List<ComponentInfo> empty = new ArrayList<>();
            List<ComponentInfo> oneComp = Arrays.asList(
                new ComponentInfo("com.example.A", "a", Scope.SINGLETON)
            );
            List<ComponentInfo> threeComp = Arrays.asList(
                new ComponentInfo("com.example.A", "a", Scope.SINGLETON),
                new ComponentInfo("com.example.B", "b", Scope.SINGLETON),
                new ComponentInfo("com.example.C", "c", Scope.SINGLETON)
            );
            
            byte[] emptyBytecode = new RegistryGenerator(empty).generate();
            byte[] oneBytecode = new RegistryGenerator(oneComp).generate();
            byte[] threeBytecode = new RegistryGenerator(threeComp).generate();
            
            assertTrue(oneBytecode.length > emptyBytecode.length,
                "One component should produce larger bytecode than empty");
            assertTrue(threeBytecode.length > oneBytecode.length,
                "Three components should produce larger bytecode than one");
        }

        @Test
        @DisplayName("should handle component with interfaces")
        void shouldHandleComponentWithInterfaces() {
            ComponentInfo comp = new ComponentInfo(
                "com.example.ServiceImpl",
                "serviceImpl",
                Scope.SINGLETON
            );
            comp.addImplementedInterface("com.example.Service");
            comp.addImplementedInterface("com.example.OtherService");
            
            List<ComponentInfo> components = Arrays.asList(comp);
            RegistryGenerator generator = new RegistryGenerator(components);
            
            byte[] bytecode = generator.generate();
            
            assertNotNull(bytecode);
            assertTrue(bytecode.length > 0);
            
            // Verify it's valid bytecode
            ClassNode cn = parseClass(bytecode);
            assertNotNull(cn);
            assertEquals("io/github/yasmramos/VeldRegistry", cn.name);
        }

        @Test
        @DisplayName("should handle mixed scope components")
        void shouldHandleMixedScopeComponents() {
            List<ComponentInfo> components = Arrays.asList(
                new ComponentInfo("com.example.SingletonA", "singletonA", Scope.SINGLETON),
                new ComponentInfo("com.example.PrototypeA", "prototypeA", Scope.PROTOTYPE),
                new ComponentInfo("com.example.SingletonB", "singletonB", Scope.SINGLETON),
                new ComponentInfo("com.example.PrototypeB", "prototypeB", Scope.PROTOTYPE)
            );
            
            RegistryGenerator generator = new RegistryGenerator(components);
            byte[] bytecode = generator.generate();
            
            assertNotNull(bytecode);
            assertTrue(bytecode.length > 0);
            
            ClassNode cn = parseClass(bytecode);
            assertNotNull(cn);
        }

        @Test
        @DisplayName("should handle lazy components")
        void shouldHandleLazyComponents() {
            List<ComponentInfo> components = Arrays.asList(
                new ComponentInfo("com.example.LazyService", "lazyService", Scope.SINGLETON, true),
                new ComponentInfo("com.example.EagerService", "eagerService", Scope.SINGLETON, false)
            );
            
            RegistryGenerator generator = new RegistryGenerator(components);
            byte[] bytecode = generator.generate();
            
            assertNotNull(bytecode);
            assertTrue(bytecode.length > 0);
        }

        @Test
        @DisplayName("should handle conditional components")
        void shouldHandleConditionalComponents() {
            ComponentInfo conditional = new ComponentInfo(
                "com.example.ConditionalService",
                "conditionalService",
                Scope.SINGLETON
            );
            ConditionInfo conditions = new ConditionInfo();
            conditions.addPropertyCondition("feature.enabled", "true", false);
            conditional.setConditionInfo(conditions);
            
            List<ComponentInfo> components = Arrays.asList(conditional);
            RegistryGenerator generator = new RegistryGenerator(components);
            
            byte[] bytecode = generator.generate();
            
            assertNotNull(bytecode);
            assertTrue(bytecode.length > 0);
        }
    }

    @Nested
    @DisplayName("Bytecode Validity Tests")
    class BytecodeValidityTests {

        @Test
        @DisplayName("should generate parseable bytecode")
        void shouldGenerateParseableBytecode() {
            List<ComponentInfo> components = Arrays.asList(
                new ComponentInfo("com.example.Test", "test", Scope.SINGLETON)
            );
            RegistryGenerator generator = new RegistryGenerator(components);
            
            byte[] bytecode = generator.generate();
            
            // This should not throw an exception
            assertDoesNotThrow(() -> parseClass(bytecode));
        }

        @Test
        @DisplayName("should generate Java 17 compatible bytecode")
        void shouldGenerateJava17CompatibleBytecode() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            // Java 17 = version 61
            assertEquals(Opcodes.V17, cn.version);
        }

        @Test
        @DisplayName("should generate reasonable bytecode size")
        void shouldGenerateReasonableBytecodeSize() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            
            // Empty registry should be between 500 bytes and 5KB
            assertTrue(bytecode.length > 500, "Bytecode too small: " + bytecode.length);
            assertTrue(bytecode.length < 5000, "Bytecode too large: " + bytecode.length);
        }

        @Test
        @DisplayName("bytecode should have correct magic number")
        void bytecodeShouldHaveCorrectMagicNumber() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            
            // Java class file magic number: 0xCAFEBABE
            assertEquals((byte) 0xCA, bytecode[0]);
            assertEquals((byte) 0xFE, bytecode[1]);
            assertEquals((byte) 0xBA, bytecode[2]);
            assertEquals((byte) 0xBE, bytecode[3]);
        }
    }

    @Nested
    @DisplayName("Method Signatures Tests")
    class MethodSignaturesTests {

        @Test
        @DisplayName("getAllFactories should have correct signature")
        void getAllFactoriesShouldHaveCorrectSignature() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            MethodNode method = getMethod(cn, "getAllFactories");
            assertNotNull(method);
            
            // Should have generic signature for List<ComponentFactory<?>>
            assertNotNull(method.signature);
            assertTrue(method.signature.contains("ComponentFactory"));
        }

        @Test
        @DisplayName("getFactory by type should have correct signature")
        void getFactoryByTypeShouldHaveCorrectSignature() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            MethodNode method = cn.methods.stream()
                .filter(m -> m.name.equals("getFactory") 
                    && m.desc.equals("(Ljava/lang/Class;)Lcom/veld/runtime/ComponentFactory;"))
                .findFirst()
                .orElse(null);
            
            assertNotNull(method);
            assertNotNull(method.signature);
        }

        @Test
        @DisplayName("getFactoriesForType should have correct signature")
        void getFactoriesForTypeShouldHaveCorrectSignature() {
            RegistryGenerator generator = new RegistryGenerator(new ArrayList<>());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            MethodNode method = getMethod(cn, "getFactoriesForType");
            assertNotNull(method);
            
            // Should have generic signature
            assertNotNull(method.signature);
            assertTrue(method.signature.contains("ComponentFactory"));
        }
    }

    @Nested
    @DisplayName("Edge Cases")
    class EdgeCasesTests {

        @Test
        @DisplayName("should handle component with long class name")
        void shouldHandleComponentWithLongClassName() {
            String longName = "com.example.very.deep.package.hierarchy." +
                "that.goes.on.for.a.while.MyVeryLongComponentName";
            
            ComponentInfo comp = new ComponentInfo(longName, "comp", Scope.SINGLETON);
            RegistryGenerator generator = new RegistryGenerator(Arrays.asList(comp));
            
            byte[] bytecode = generator.generate();
            
            assertNotNull(bytecode);
            assertDoesNotThrow(() -> parseClass(bytecode));
        }

        @Test
        @DisplayName("should handle many components")
        void shouldHandleManyComponents() {
            List<ComponentInfo> components = new ArrayList<>();
            for (int i = 0; i < 50; i++) {
                components.add(new ComponentInfo(
                    "com.example.Service" + i,
                    "service" + i,
                    i % 2 == 0 ? Scope.SINGLETON : Scope.PROTOTYPE
                ));
            }
            
            RegistryGenerator generator = new RegistryGenerator(components);
            byte[] bytecode = generator.generate();
            
            assertNotNull(bytecode);
            assertTrue(bytecode.length > 0);
            assertDoesNotThrow(() -> parseClass(bytecode));
        }

        @Test
        @DisplayName("should handle component with many interfaces")
        void shouldHandleComponentWithManyInterfaces() {
            ComponentInfo comp = new ComponentInfo(
                "com.example.MultiInterfaceService",
                "multiInterfaceService",
                Scope.SINGLETON
            );
            
            for (int i = 0; i < 10; i++) {
                comp.addImplementedInterface("com.example.Interface" + i);
            }
            
            RegistryGenerator generator = new RegistryGenerator(Arrays.asList(comp));
            byte[] bytecode = generator.generate();
            
            assertNotNull(bytecode);
            assertDoesNotThrow(() -> parseClass(bytecode));
        }
    }
}
