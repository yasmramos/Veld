/*
 * Copyright 2025 Veld Framework
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.yasmramos.processor;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.List;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for {@link VeldBootstrapGenerator} bytecode generation.
 * Uses ASM ClassReader to inspect generated bytecode without loading classes.
 */
@DisplayName("VeldBootstrapGenerator Tests")
class VeldBootstrapGeneratorTest {

    /**
     * Parses bytecode into a ClassNode for inspection.
     */
    private ClassNode parseClass(byte[] bytecode) {
        ClassReader cr = new ClassReader(bytecode);
        ClassNode cn = new ClassNode();
        cr.accept(cn, 0);
        return cn;
    }

    /**
     * Gets method names from a ClassNode.
     */
    private List<String> getMethodNames(ClassNode cn) {
        return cn.methods.stream()
            .map(m -> m.name)
            .collect(Collectors.toList());
    }

    /**
     * Checks if a method exists in the ClassNode.
     */
    private boolean hasMethod(ClassNode cn, String methodName) {
        return cn.methods.stream().anyMatch(m -> m.name.equals(methodName));
    }

    /**
     * Gets a method by name from ClassNode.
     */
    private MethodNode getMethod(ClassNode cn, String methodName) {
        return cn.methods.stream()
            .filter(m -> m.name.equals(methodName))
            .findFirst()
            .orElse(null);
    }

    @Nested
    @DisplayName("Basic Generation Tests")
    class BasicGenerationTests {

        @Test
        @DisplayName("should generate valid bytecode")
        void shouldGenerateValidBytecode() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            
            byte[] bytecode = generator.generate();
            
            assertNotNull(bytecode);
            assertTrue(bytecode.length > 0);
        }

        @Test
        @DisplayName("should return correct class name")
        void shouldReturnCorrectClassName() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            
            assertEquals("io.github.yasmramos.generated.Veld", generator.getClassName());
        }

        @Test
        @DisplayName("should generate parseable bytecode")
        void shouldGenerateParseableBytecode() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            
            assertDoesNotThrow(() -> parseClass(bytecode));
        }
    }

    @Nested
    @DisplayName("Class Structure Tests")
    class ClassStructureTests {

        @Test
        @DisplayName("should generate class with correct name")
        void shouldGenerateClassWithCorrectName() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertEquals("io/github/yasmramos/Veld", cn.name);
        }

        @Test
        @DisplayName("should generate public final class")
        void shouldGeneratePublicFinalClass() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue((cn.access & Opcodes.ACC_PUBLIC) != 0, "Should be public");
            assertTrue((cn.access & Opcodes.ACC_FINAL) != 0, "Should be final");
        }

        @Test
        @DisplayName("should extend Object")
        void shouldExtendObject() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertEquals("java/lang/Object", cn.superName);
        }

        @Test
        @DisplayName("should not implement any interface")
        void shouldNotImplementAnyInterface() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue(cn.interfaces == null || cn.interfaces.isEmpty());
        }

        @Test
        @DisplayName("should generate Java 17 compatible bytecode")
        void shouldGenerateJava17CompatibleBytecode() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertEquals(Opcodes.V17, cn.version);
        }
    }

    @Nested
    @DisplayName("Constructor Tests")
    class ConstructorTests {

        @Test
        @DisplayName("should generate private constructor")
        void shouldGeneratePrivateConstructor() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue(hasMethod(cn, "<init>"));
            
            MethodNode initMethod = getMethod(cn, "<init>");
            assertNotNull(initMethod);
            assertEquals("()V", initMethod.desc);
            assertTrue((initMethod.access & Opcodes.ACC_PRIVATE) != 0, "Constructor should be private");
        }

        @Test
        @DisplayName("private constructor prevents instantiation")
        void privateConstructorPreventsInstantiation() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            MethodNode initMethod = getMethod(cn, "<init>");
            assertNotNull(initMethod);
            
            // Verify it's not public
            assertFalse((initMethod.access & Opcodes.ACC_PUBLIC) != 0, "Constructor should not be public");
        }
    }

    @Nested
    @DisplayName("Static Method Tests")
    class StaticMethodTests {

        @Test
        @DisplayName("should generate createContainer method")
        void shouldGenerateCreateContainerMethod() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue(hasMethod(cn, "createContainer"));
        }

        @Test
        @DisplayName("createContainer should be public static")
        void createContainerShouldBePublicStatic() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            MethodNode method = getMethod(cn, "createContainer");
            assertNotNull(method);
            assertTrue((method.access & Opcodes.ACC_PUBLIC) != 0, "Should be public");
            assertTrue((method.access & Opcodes.ACC_STATIC) != 0, "Should be static");
        }

        @Test
        @DisplayName("should generate get method for type lookup")
        void shouldGenerateGetMethod() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            MethodNode method = getMethod(cn, "get");
            assertNotNull(method, "Should have get method");
            assertTrue((method.access & Opcodes.ACC_PUBLIC) != 0, "Should be public");
            assertTrue((method.access & Opcodes.ACC_STATIC) != 0, "Should be static");
        }

        @Test
        @DisplayName("should generate contains method")
        void shouldGenerateContainsMethod() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            MethodNode method = getMethod(cn, "contains");
            assertNotNull(method, "Should have contains method");
            assertTrue((method.access & Opcodes.ACC_STATIC) != 0, "Should be static");
        }

        @Test
        @DisplayName("should generate createRegistry method")
        void shouldGenerateCreateRegistryMethod() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            assertTrue(hasMethod(cn, "createRegistry"));
        }

        @Test
        @DisplayName("createRegistry should be public static")
        void createRegistryShouldBePublicStatic() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            MethodNode method = getMethod(cn, "createRegistry");
            assertNotNull(method);
            assertTrue((method.access & Opcodes.ACC_PUBLIC) != 0, "Should be public");
            assertTrue((method.access & Opcodes.ACC_STATIC) != 0, "Should be static");
        }

        @Test
        @DisplayName("createRegistry should return ComponentRegistry")
        void createRegistryShouldReturnComponentRegistry() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            MethodNode method = getMethod(cn, "createRegistry");
            assertNotNull(method);
            assertEquals("()Lio/github/yasmramos/runtime/ComponentRegistry;", method.desc);
        }

        @Test
        @DisplayName("createRegistry should have no parameters")
        void createRegistryShouldHaveNoParameters() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            MethodNode method = getMethod(cn, "createRegistry");
            assertNotNull(method);
            assertTrue(method.desc.startsWith("()"), "Should have no parameters");
        }
    }

    @Nested
    @DisplayName("Method Count Tests")
    class MethodCountTests {

        @Test
        @DisplayName("should generate at least eight core methods")
        void shouldGenerateAtLeastEightCoreMethods() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            // Should have: <clinit>, <init>, createContainer, createRegistry, get, getAll, contains, componentCount
            assertTrue(cn.methods.size() >= 8, "Should have at least 8 methods, found: " + cn.methods.size());
        }

        @Test
        @DisplayName("should generate all required methods")
        void shouldGenerateAllRequiredMethods() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            List<String> methods = getMethodNames(cn);
            
            assertTrue(methods.contains("<init>"), "Should have constructor");
            assertTrue(methods.contains("createContainer"), "Should have createContainer");
            assertTrue(methods.contains("createRegistry"), "Should have createRegistry");
        }
    }

    @Nested
    @DisplayName("Internal Fields Tests")
    class InternalFieldsTests {

        @Test
        @DisplayName("should generate internal lookup fields")
        void shouldGenerateInternalLookupFields() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            // Should have internal lookup arrays: _types, _instances, _scopes
            assertTrue(cn.fields != null && cn.fields.size() >= 3, 
                "Bootstrap class should have internal lookup fields");
        }
    }

    @Nested
    @DisplayName("Bytecode Validity Tests")
    class BytecodeValidityTests {

        @Test
        @DisplayName("bytecode should have correct magic number")
        void bytecodeShouldHaveCorrectMagicNumber() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            
            // Java class file magic number: 0xCAFEBABE
            assertEquals((byte) 0xCA, bytecode[0]);
            assertEquals((byte) 0xFE, bytecode[1]);
            assertEquals((byte) 0xBA, bytecode[2]);
            assertEquals((byte) 0xBE, bytecode[3]);
        }

        @Test
        @DisplayName("should generate reasonable bytecode size")
        void shouldGenerateReasonableBytecodeSize() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            
            // Simple bootstrap class should be between 300 bytes and 2KB
            assertTrue(bytecode.length > 300, "Bytecode too small: " + bytecode.length);
            assertTrue(bytecode.length < 2000, "Bytecode too large: " + bytecode.length);
        }
    }

    @Nested
    @DisplayName("Multiple Generation Tests")
    class MultipleGenerationTests {

        @Test
        @DisplayName("should generate consistent bytecode on multiple calls")
        void shouldGenerateConsistentBytecode() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            
            byte[] bytecode1 = generator.generate();
            byte[] bytecode2 = generator.generate();
            
            assertArrayEquals(bytecode1, bytecode2, 
                "Same generator should produce identical bytecode");
        }

        @Test
        @DisplayName("different instances should generate same bytecode")
        void differentInstancesShouldGenerateSameBytecode() {
            VeldBootstrapGenerator generator1 = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            VeldBootstrapGenerator generator2 = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            
            byte[] bytecode1 = generator1.generate();
            byte[] bytecode2 = generator2.generate();
            
            assertArrayEquals(bytecode1, bytecode2, 
                "Different instances should produce identical bytecode");
        }
    }

    @Nested
    @DisplayName("Method Instruction Tests")
    class MethodInstructionTests {

        @Test
        @DisplayName("createContainer should have method invocations")
        void createContainerShouldHaveMethodInvocations() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            MethodNode method = getMethod(cn, "createContainer");
            assertNotNull(method);
            
            // Method should have instructions
            assertNotNull(method.instructions);
            assertTrue(method.instructions.size() > 0, 
                "createContainer should have instructions");
        }

        @Test
        @DisplayName("createRegistry should have method invocations")
        void createRegistryShouldHaveMethodInvocations() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            MethodNode method = getMethod(cn, "createRegistry");
            assertNotNull(method);
            
            // Method should have instructions
            assertNotNull(method.instructions);
            assertTrue(method.instructions.size() > 0, 
                "createRegistry should have instructions");
        }

        @Test
        @DisplayName("constructor should call super()")
        void constructorShouldCallSuper() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            MethodNode initMethod = getMethod(cn, "<init>");
            assertNotNull(initMethod);
            
            // Constructor should have instructions (including INVOKESPECIAL for super())
            assertNotNull(initMethod.instructions);
            assertTrue(initMethod.instructions.size() > 0, 
                "Constructor should have instructions");
        }
    }

    @Nested
    @DisplayName("Class Name Consistency Tests")
    class ClassNameConsistencyTests {

        @Test
        @DisplayName("getClassName should match generated class")
        void getClassNameShouldMatchGeneratedClass() {
            VeldBootstrapGenerator generator = new VeldBootstrapGenerator(java.util.Collections.emptyList());
            
            String expectedName = generator.getClassName();
            byte[] bytecode = generator.generate();
            ClassNode cn = parseClass(bytecode);
            
            String actualName = cn.name.replace('/', '.');
            assertEquals(expectedName, actualName);
        }
    }
}
