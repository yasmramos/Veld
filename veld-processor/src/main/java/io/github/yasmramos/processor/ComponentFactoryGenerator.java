package io.github.yasmramos.processor;

import io.github.yasmramos.processor.InjectionPoint.Dependency;
import io.github.yasmramos.runtime.Scope;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;

import static org.objectweb.asm.Opcodes.*;

/**
 * Generates bytecode for ComponentFactory implementations using ASM.
 * NO REFLECTION - pure bytecode generation.
 * 
 * Generated class structure:
 * <pre>
 * public class MyService$$VeldFactory implements ComponentFactory<MyService> {
 *     
 *     public MyService$$VeldFactory() { }
 *     
 *     public MyService create(Veld container) {
 *         // Instantiate and inject dependencies
 *         // Dependencies resolved via container.get()
 *     }
 *     
 *     public Class<MyService> getComponentType() { return MyService.class; }
 *     public String getComponentName() { return "myService"; }
 *     public Scope getScope() { return Scope.SINGLETON; }
 *     public void invokePostConstruct(MyService instance) { instance.init(); }
 *     public void invokePreDestroy(MyService instance) { instance.cleanup(); }
 * }
 * </pre>
 */
public final class ComponentFactoryGenerator {
    
    private static final String COMPONENT_FACTORY = "com/veld/runtime/ComponentFactory";
    private static final String VELD_CLASS = "com/veld/Veld";
    private static final String SCOPE = "com/veld/runtime/Scope";
    private static final String PROVIDER = "com/veld/runtime/Provider";
    private static final String OPTIONAL = "java/util/Optional";
    private static final String OBJECT = "java/lang/Object";
    private static final String CLASS = "java/lang/Class";
    private static final String STRING = "java/lang/String";
    private static final String LIST = "java/util/List";
    private static final String ARRAYS = "java/util/Arrays";
    private static final String CONDITION_CONTEXT = "com/veld/runtime/condition/ConditionContext";
    private static final String CONDITION_EVALUATOR = "com/veld/runtime/condition/ConditionEvaluator";
    private static final String VALUE_RESOLVER = "com/veld/runtime/value/ValueResolver";
    
    /** Prefix for synthetic setter methods generated by veld-weaver for private field injection */
    private static final String SYNTHETIC_SETTER_PREFIX = "__di_set_";
    
    private final ComponentInfo component;
    private final int componentIndex;
    
    public ComponentFactoryGenerator(ComponentInfo component) {
        this(component, -1);
    }
    
    public ComponentFactoryGenerator(ComponentInfo component, int componentIndex) {
        this.component = component;
        this.componentIndex = componentIndex;
    }
    
    /**
     * Generates the complete bytecode for the factory class.
     * @return The bytecode as a byte array
     */
    public byte[] generate() {
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
        
        String factoryInternal = component.getFactoryInternalName();
        String componentInternal = component.getInternalName();
        
        // Class declaration: public class X$$VeldFactory implements ComponentFactory<X>
        String signature = "L" + OBJECT + ";L" + COMPONENT_FACTORY + "<L" + componentInternal + ";>;";
        cw.visit(V11, ACC_PUBLIC | ACC_FINAL | ACC_SUPER,
                factoryInternal,
                signature,
                OBJECT,
                new String[]{COMPONENT_FACTORY});
        
        // Default constructor
        generateConstructor(cw);
        
        // create(Veld) method
        generateCreateMethod(cw, factoryInternal, componentInternal);
        
        // getComponentType() method
        generateGetComponentType(cw, componentInternal);
        
        // getComponentName() method
        generateGetComponentName(cw);
        
        // getScope() method
        generateGetScope(cw);
        
        // isLazy() method (only if component is lazy)
        if (component.isLazy()) {
            generateIsLazy(cw);
        }
        
        // invokePostConstruct(T) method
        generateInvokePostConstruct(cw, componentInternal);
        
        // invokePreDestroy(T) method
        generateInvokePreDestroy(cw, componentInternal);
        
        // Conditional registration methods
        if (component.hasConditions()) {
            generateHasConditions(cw);
            generateEvaluateConditions(cw);
            generateCreateConditionEvaluator(cw);
        }
        
        // getImplementedInterfaces() method
        if (component.hasImplementedInterfaces()) {
            generateGetImplementedInterfaces(cw);
        }
        
        // getIndex() method for ultra-fast array-based lookups
        generateGetIndex(cw);
        
        // Bridge methods for type erasure
        generateBridgeMethods(cw, factoryInternal, componentInternal);
        
        cw.visitEnd();
        return cw.toByteArray();
    }
    
    private void generateConstructor(ClassWriter cw) {
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
        mv.visitCode();
        
        // super()
        mv.visitVarInsn(ALOAD, 0);
        mv.visitMethodInsn(INVOKESPECIAL, OBJECT, "<init>", "()V", false);
        
        mv.visitInsn(RETURN);
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
    
    private void generateCreateMethod(ClassWriter cw, String factoryInternal, String componentInternal) {
        // public T create()
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "create",
                "()L" + componentInternal + ";", null, null);
        mv.visitCode();
        
        InjectionPoint constructor = component.getConstructorInjection();
        
        if (constructor == null || constructor.getDependencies().isEmpty()) {
            // new Component()
            mv.visitTypeInsn(NEW, componentInternal);
            mv.visitInsn(DUP);
            mv.visitMethodInsn(INVOKESPECIAL, componentInternal, "<init>", "()V", false);
        } else {
            // new Component(dep1, dep2, ...)
            mv.visitTypeInsn(NEW, componentInternal);
            mv.visitInsn(DUP);
            
            // Load each dependency from container
            for (Dependency dep : constructor.getDependencies()) {
                loadDependency(mv, dep);
            }
            
            mv.visitMethodInsn(INVOKESPECIAL, componentInternal, "<init>",
                    constructor.getDescriptor(), false);
        }
        
        // Store instance in local variable 1 (0=this, 1=instance)
        mv.visitVarInsn(ASTORE, 1);
        
        // Field injections
        for (InjectionPoint field : component.getFieldInjections()) {
            mv.visitVarInsn(ALOAD, 1);
            Dependency dep = field.getDependencies().get(0);
            loadDependency(mv, dep);
            
            if (field.requiresSyntheticSetter()) {
                // Private field - use synthetic setter generated by veld-weaver
                // Call: instance.__di_set_fieldName(value)
                String setterName = SYNTHETIC_SETTER_PREFIX + field.getName();
                String setterDesc = "(" + field.getDescriptor() + ")V";
                mv.visitMethodInsn(INVOKEVIRTUAL, componentInternal, setterName, setterDesc, false);
            } else {
                // Non-private field - direct PUTFIELD access
                mv.visitFieldInsn(PUTFIELD, componentInternal, field.getName(), field.getDescriptor());
            }
        }
        
        // Method injections
        for (InjectionPoint method : component.getMethodInjections()) {
            mv.visitVarInsn(ALOAD, 1);
            for (Dependency dep : method.getDependencies()) {
                loadDependency(mv, dep);
            }
            mv.visitMethodInsn(INVOKEVIRTUAL, componentInternal, 
                    method.getName(), method.getDescriptor(), false);
        }
        
        // Return instance
        mv.visitVarInsn(ALOAD, 1);
        mv.visitInsn(ARETURN);
        
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
    
    private void loadDependency(MethodVisitor mv, Dependency dep) {
        if (dep.isValueInjection()) {
            // For @Value, resolve the value expression
            loadValueDependency(mv, dep);
        } else if (dep.isOptionalWrapper()) {
            // For Optional<T>, call container.getOptional(T.class)
            loadOptionalWrapperDependency(mv, dep);
        } else if (dep.isOptional()) {
            // For @Optional, call container.tryGet(T.class) which returns null if not found
            loadOptionalDependency(mv, dep);
        } else if (dep.isProvider()) {
            // For Provider<T>, call container.getProvider(T.class)
            loadProviderDependency(mv, dep);
        } else if (dep.isLazy()) {
            // For @Lazy, wrap in a LazyHolder that calls container.get() on first access
            loadLazyDependency(mv, dep);
        } else {
            // Regular dependency
            loadRegularDependency(mv, dep);
        }
    }
    
    private void loadValueDependency(MethodVisitor mv, Dependency dep) {
        String valueExpression = dep.getValueExpression();
        String typeName = dep.getTypeName();
        
        // ValueResolver.getInstance().resolve(expression, targetType)
        mv.visitMethodInsn(INVOKESTATIC, VALUE_RESOLVER, "getInstance",
                "()L" + VALUE_RESOLVER + ";", false);
        mv.visitLdcInsn(valueExpression);
        
        // Get the target class for type conversion
        switch (typeName) {
            case "int":
                mv.visitLdcInsn(org.objectweb.asm.Type.getType("Ljava/lang/Integer;"));
                break;
            case "long":
                mv.visitLdcInsn(org.objectweb.asm.Type.getType("Ljava/lang/Long;"));
                break;
            case "double":
                mv.visitLdcInsn(org.objectweb.asm.Type.getType("Ljava/lang/Double;"));
                break;
            case "float":
                mv.visitLdcInsn(org.objectweb.asm.Type.getType("Ljava/lang/Float;"));
                break;
            case "boolean":
                mv.visitLdcInsn(org.objectweb.asm.Type.getType("Ljava/lang/Boolean;"));
                break;
            case "byte":
                mv.visitLdcInsn(org.objectweb.asm.Type.getType("Ljava/lang/Byte;"));
                break;
            case "short":
                mv.visitLdcInsn(org.objectweb.asm.Type.getType("Ljava/lang/Short;"));
                break;
            case "char":
                mv.visitLdcInsn(org.objectweb.asm.Type.getType("Ljava/lang/Character;"));
                break;
            default:
                // Object type (usually String)
                String typeInternal = typeName.replace('.', '/');
                mv.visitLdcInsn(org.objectweb.asm.Type.getObjectType(typeInternal));
                break;
        }
        
        mv.visitMethodInsn(INVOKEVIRTUAL, VALUE_RESOLVER, "resolve",
                "(L" + STRING + ";L" + CLASS + ";)L" + OBJECT + ";", false);
        
        // Convert to primitive if necessary
        switch (typeName) {
            case "int":
                mv.visitTypeInsn(CHECKCAST, "java/lang/Integer");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false);
                break;
            case "long":
                mv.visitTypeInsn(CHECKCAST, "java/lang/Long");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false);
                break;
            case "double":
                mv.visitTypeInsn(CHECKCAST, "java/lang/Double");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false);
                break;
            case "float":
                mv.visitTypeInsn(CHECKCAST, "java/lang/Float");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false);
                break;
            case "boolean":
                mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false);
                break;
            case "byte":
                mv.visitTypeInsn(CHECKCAST, "java/lang/Byte");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false);
                break;
            case "short":
                mv.visitTypeInsn(CHECKCAST, "java/lang/Short");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false);
                break;
            case "char":
                mv.visitTypeInsn(CHECKCAST, "java/lang/Character");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false);
                break;
            default:
                // Object type - cast to target type
                String typeInternal = typeName.replace('.', '/');
                mv.visitTypeInsn(CHECKCAST, typeInternal);
                break;
        }
    }
    
    private void loadRegularDependency(MethodVisitor mv, Dependency dep) {
        String depInternal = dep.getTypeName().replace('.', '/');
        
        if (dep.hasQualifier()) {
            // Veld.get(DependencyType.class, "qualifierName")
            mv.visitLdcInsn(org.objectweb.asm.Type.getObjectType(depInternal));
            mv.visitLdcInsn(dep.getQualifierName());
            mv.visitMethodInsn(INVOKESTATIC, VELD_CLASS, "get",
                    "(L" + CLASS + ";L" + STRING + ";)L" + OBJECT + ";", false);
        } else {
            // Veld.get(DependencyType.class)
            mv.visitLdcInsn(org.objectweb.asm.Type.getObjectType(depInternal));
            mv.visitMethodInsn(INVOKESTATIC, VELD_CLASS, "get",
                    "(L" + CLASS + ";)L" + OBJECT + ";", false);
        }
        
        // Cast to dependency type
        mv.visitTypeInsn(CHECKCAST, depInternal);
    }
    
    private void loadProviderDependency(MethodVisitor mv, Dependency dep) {
        String actualTypeInternal = dep.getActualTypeName().replace('.', '/');
        
        // Create a lambda Provider that calls Veld.get()
        // For now, just load via Veld.get() directly (simplified)
        mv.visitLdcInsn(org.objectweb.asm.Type.getObjectType(actualTypeInternal));
        mv.visitMethodInsn(INVOKESTATIC, VELD_CLASS, "get",
                "(L" + CLASS + ";)L" + OBJECT + ";", false);
        mv.visitTypeInsn(CHECKCAST, actualTypeInternal);
    }
    
    private void loadLazyDependency(MethodVisitor mv, Dependency dep) {
        String actualTypeInternal = dep.getActualTypeName().replace('.', '/');
        
        // Veld.get(ActualType.class) - lazy is handled by static initialization
        mv.visitLdcInsn(org.objectweb.asm.Type.getObjectType(actualTypeInternal));
        mv.visitMethodInsn(INVOKESTATIC, VELD_CLASS, "get",
                "(L" + CLASS + ";)L" + OBJECT + ";", false);
        
        // Cast to dependency type
        mv.visitTypeInsn(CHECKCAST, actualTypeInternal);
    }
    
    private void loadOptionalDependency(MethodVisitor mv, Dependency dep) {
        String depInternal = dep.getActualTypeName().replace('.', '/');
        
        // Veld.get(DependencyType.class) - returns null if not found
        mv.visitLdcInsn(org.objectweb.asm.Type.getObjectType(depInternal));
        mv.visitMethodInsn(INVOKESTATIC, VELD_CLASS, "get",
                "(L" + CLASS + ";)L" + OBJECT + ";", false);
        
        // Cast to dependency type (or null)
        mv.visitTypeInsn(CHECKCAST, depInternal);
    }
    
    private void loadOptionalWrapperDependency(MethodVisitor mv, Dependency dep) {
        String actualTypeInternal = dep.getActualTypeName().replace('.', '/');
        
        // Optional.ofNullable(Veld.get(ActualType.class))
        mv.visitLdcInsn(org.objectweb.asm.Type.getObjectType(actualTypeInternal));
        mv.visitMethodInsn(INVOKESTATIC, VELD_CLASS, "get",
                "(L" + CLASS + ";)L" + OBJECT + ";", false);
        mv.visitMethodInsn(INVOKESTATIC, OPTIONAL, "ofNullable",
                "(L" + OBJECT + ";)L" + OPTIONAL + ";", false);
    }
    
    private void generateGetComponentType(ClassWriter cw, String componentInternal) {
        String signature = "()L" + CLASS + "<L" + componentInternal + ";>;";
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "getComponentType",
                "()L" + CLASS + ";", signature, null);
        mv.visitCode();
        
        mv.visitLdcInsn(org.objectweb.asm.Type.getObjectType(componentInternal));
        mv.visitInsn(ARETURN);
        
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
    
    private void generateGetComponentName(ClassWriter cw) {
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "getComponentName",
                "()L" + STRING + ";", null, null);
        mv.visitCode();
        
        mv.visitLdcInsn(component.getComponentName());
        mv.visitInsn(ARETURN);
        
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
    
    private void generateGetScope(ClassWriter cw) {
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "getScope",
                "()L" + SCOPE + ";", null, null);
        mv.visitCode();
        
        String scopeName = component.getScope() == Scope.SINGLETON ? "SINGLETON" : "PROTOTYPE";
        mv.visitFieldInsn(GETSTATIC, SCOPE, scopeName, "L" + SCOPE + ";");
        mv.visitInsn(ARETURN);
        
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
    
    private void generateIsLazy(ClassWriter cw) {
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "isLazy",
                "()Z", null, null);
        mv.visitCode();
        
        mv.visitInsn(ICONST_1); // return true
        mv.visitInsn(IRETURN);
        
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
    
    private void generateInvokePostConstruct(ClassWriter cw, String componentInternal) {
        // invokePostConstruct(T instance) - with generic type
        String signature = "(L" + componentInternal + ";)V";
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "invokePostConstruct",
                "(L" + componentInternal + ";)V", null, null);
        mv.visitCode();
        
        if (component.hasPostConstruct()) {
            mv.visitVarInsn(ALOAD, 1);
            mv.visitMethodInsn(INVOKEVIRTUAL, componentInternal,
                    component.getPostConstructMethod(), 
                    component.getPostConstructDescriptor(), false);
        }
        
        mv.visitInsn(RETURN);
        mv.visitMaxs(0, 0);
        mv.visitEnd();
        
        // Bridge method: invokePostConstruct(Object) -> invokePostConstruct(T)
        MethodVisitor bridge = cw.visitMethod(ACC_PUBLIC | ACC_BRIDGE | ACC_SYNTHETIC,
                "invokePostConstruct", "(L" + OBJECT + ";)V", null, null);
        bridge.visitCode();
        
        bridge.visitVarInsn(ALOAD, 0);
        bridge.visitVarInsn(ALOAD, 1);
        bridge.visitTypeInsn(CHECKCAST, componentInternal);
        bridge.visitMethodInsn(INVOKEVIRTUAL, component.getFactoryInternalName(),
                "invokePostConstruct", "(L" + componentInternal + ";)V", false);
        bridge.visitInsn(RETURN);
        
        bridge.visitMaxs(0, 0);
        bridge.visitEnd();
    }
    
    private void generateInvokePreDestroy(ClassWriter cw, String componentInternal) {
        // invokePreDestroy(T instance) - with generic type
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "invokePreDestroy",
                "(L" + componentInternal + ";)V", null, null);
        mv.visitCode();
        
        if (component.hasPreDestroy()) {
            mv.visitVarInsn(ALOAD, 1);
            mv.visitMethodInsn(INVOKEVIRTUAL, componentInternal,
                    component.getPreDestroyMethod(),
                    component.getPreDestroyDescriptor(), false);
        }
        
        mv.visitInsn(RETURN);
        mv.visitMaxs(0, 0);
        mv.visitEnd();
        
        // Bridge method: invokePreDestroy(Object) -> invokePreDestroy(T)
        MethodVisitor bridge = cw.visitMethod(ACC_PUBLIC | ACC_BRIDGE | ACC_SYNTHETIC,
                "invokePreDestroy", "(L" + OBJECT + ";)V", null, null);
        bridge.visitCode();
        
        bridge.visitVarInsn(ALOAD, 0);
        bridge.visitVarInsn(ALOAD, 1);
        bridge.visitTypeInsn(CHECKCAST, componentInternal);
        bridge.visitMethodInsn(INVOKEVIRTUAL, component.getFactoryInternalName(),
                "invokePreDestroy", "(L" + componentInternal + ";)V", false);
        bridge.visitInsn(RETURN);
        
        bridge.visitMaxs(0, 0);
        bridge.visitEnd();
    }
    
    private void generateBridgeMethods(ClassWriter cw, String factoryInternal, String componentInternal) {
        // Bridge method for create(): Object create() calls T create()
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_BRIDGE | ACC_SYNTHETIC, 
                "create", "()L" + OBJECT + ";", null, null);
        mv.visitCode();
        
        mv.visitVarInsn(ALOAD, 0);
        mv.visitMethodInsn(INVOKEVIRTUAL, factoryInternal, "create",
                "()L" + componentInternal + ";", false);
        mv.visitInsn(ARETURN);
        
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
    
    // ===================== Conditional Registration Methods =====================
    
    private void generateHasConditions(ClassWriter cw) {
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "hasConditions", "()Z", null, null);
        mv.visitCode();
        mv.visitInsn(ICONST_1); // return true
        mv.visitInsn(IRETURN);
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
    
    private void generateEvaluateConditions(ClassWriter cw) {
        // public boolean evaluateConditions(ConditionContext context)
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "evaluateConditions",
                "(L" + CONDITION_CONTEXT + ";)Z", null, null);
        mv.visitCode();
        
        // ConditionEvaluator evaluator = createConditionEvaluator();
        // return evaluator.evaluate(context);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitMethodInsn(INVOKEVIRTUAL, component.getFactoryInternalName(), 
                "createConditionEvaluator", "()L" + CONDITION_EVALUATOR + ";", false);
        mv.visitVarInsn(ALOAD, 1);
        mv.visitMethodInsn(INVOKEVIRTUAL, CONDITION_EVALUATOR, "evaluate",
                "(L" + CONDITION_CONTEXT + ";)Z", false);
        mv.visitInsn(IRETURN);
        
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
    
    private void generateCreateConditionEvaluator(ClassWriter cw) {
        // public ConditionEvaluator createConditionEvaluator()
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "createConditionEvaluator",
                "()L" + CONDITION_EVALUATOR + ";", null, null);
        mv.visitCode();
        
        ConditionInfo conditions = component.getConditionInfo();
        
        // ConditionEvaluator evaluator = new ConditionEvaluator(componentName);
        mv.visitTypeInsn(NEW, CONDITION_EVALUATOR);
        mv.visitInsn(DUP);
        mv.visitLdcInsn(component.getComponentName());
        mv.visitMethodInsn(INVOKESPECIAL, CONDITION_EVALUATOR, "<init>",
                "(L" + STRING + ";)V", false);
        mv.visitVarInsn(ASTORE, 1); // Store evaluator in local var 1
        
        // Add property conditions
        for (ConditionInfo.PropertyConditionInfo prop : conditions.getPropertyConditions()) {
            mv.visitVarInsn(ALOAD, 1);
            mv.visitLdcInsn(prop.getName());
            mv.visitLdcInsn(prop.getHavingValue() != null ? prop.getHavingValue() : "");
            mv.visitInsn(prop.isMatchIfMissing() ? ICONST_1 : ICONST_0);
            mv.visitMethodInsn(INVOKEVIRTUAL, CONDITION_EVALUATOR, "addPropertyCondition",
                    "(L" + STRING + ";L" + STRING + ";Z)L" + CONDITION_EVALUATOR + ";", false);
            mv.visitInsn(POP);
        }
        
        // Add class conditions
        for (ConditionInfo.ClassConditionInfo classInfo : conditions.getClassConditions()) {
            mv.visitVarInsn(ALOAD, 1);
            // Create String[] array with class names
            int size = classInfo.getClassNames().size();
            mv.visitIntInsn(BIPUSH, size);
            mv.visitTypeInsn(ANEWARRAY, STRING);
            
            for (int i = 0; i < size; i++) {
                mv.visitInsn(DUP);
                mv.visitIntInsn(BIPUSH, i);
                mv.visitLdcInsn(classInfo.getClassNames().get(i));
                mv.visitInsn(AASTORE);
            }
            
            mv.visitMethodInsn(INVOKEVIRTUAL, CONDITION_EVALUATOR, "addClassCondition",
                    "([L" + STRING + ";)L" + CONDITION_EVALUATOR + ";", false);
            mv.visitInsn(POP);
        }
        
        // Add missing bean conditions
        for (ConditionInfo.MissingBeanConditionInfo missing : conditions.getMissingBeanConditions()) {
            // Types
            if (!missing.getBeanTypes().isEmpty()) {
                mv.visitVarInsn(ALOAD, 1);
                int size = missing.getBeanTypes().size();
                mv.visitIntInsn(BIPUSH, size);
                mv.visitTypeInsn(ANEWARRAY, STRING);
                
                for (int i = 0; i < size; i++) {
                    mv.visitInsn(DUP);
                    mv.visitIntInsn(BIPUSH, i);
                    mv.visitLdcInsn(missing.getBeanTypes().get(i));
                    mv.visitInsn(AASTORE);
                }
                
                mv.visitMethodInsn(INVOKEVIRTUAL, CONDITION_EVALUATOR, "addMissingBeanCondition",
                        "([L" + STRING + ";)L" + CONDITION_EVALUATOR + ";", false);
                mv.visitInsn(POP);
            }
            
            // Names
            if (!missing.getBeanNames().isEmpty()) {
                mv.visitVarInsn(ALOAD, 1);
                int size = missing.getBeanNames().size();
                mv.visitIntInsn(BIPUSH, size);
                mv.visitTypeInsn(ANEWARRAY, STRING);
                
                for (int i = 0; i < size; i++) {
                    mv.visitInsn(DUP);
                    mv.visitIntInsn(BIPUSH, i);
                    mv.visitLdcInsn(missing.getBeanNames().get(i));
                    mv.visitInsn(AASTORE);
                }
                
                mv.visitMethodInsn(INVOKEVIRTUAL, CONDITION_EVALUATOR, "addMissingBeanNameCondition",
                        "([L" + STRING + ";)L" + CONDITION_EVALUATOR + ";", false);
                mv.visitInsn(POP);
            }
        }
        
        // Add profile conditions
        for (ConditionInfo.ProfileConditionInfo profile : conditions.getProfileConditions()) {
            mv.visitVarInsn(ALOAD, 1);
            // Create String[] array with profile names
            int size = profile.getProfiles().size();
            mv.visitIntInsn(BIPUSH, size);
            mv.visitTypeInsn(ANEWARRAY, STRING);
            
            for (int i = 0; i < size; i++) {
                mv.visitInsn(DUP);
                mv.visitIntInsn(BIPUSH, i);
                mv.visitLdcInsn(profile.getProfiles().get(i));
                mv.visitInsn(AASTORE);
            }
            
            mv.visitMethodInsn(INVOKEVIRTUAL, CONDITION_EVALUATOR, "addProfileCondition",
                    "([L" + STRING + ";)L" + CONDITION_EVALUATOR + ";", false);
            mv.visitInsn(POP);
        }
        
        // return evaluator;
        mv.visitVarInsn(ALOAD, 1);
        mv.visitInsn(ARETURN);
        
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
    
    private void generateGetImplementedInterfaces(ClassWriter cw) {
        // public List<String> getImplementedInterfaces()
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "getImplementedInterfaces",
                "()L" + LIST + ";", "()L" + LIST + "<L" + STRING + ";>;", null);
        mv.visitCode();
        
        java.util.List<String> interfaces = component.getImplementedInterfaces();
        int size = interfaces.size();
        
        // return Arrays.asList("Interface1", "Interface2", ...);
        mv.visitIntInsn(BIPUSH, size);
        mv.visitTypeInsn(ANEWARRAY, STRING);
        
        for (int i = 0; i < size; i++) {
            mv.visitInsn(DUP);
            mv.visitIntInsn(BIPUSH, i);
            mv.visitLdcInsn(interfaces.get(i));
            mv.visitInsn(AASTORE);
        }
        
        mv.visitMethodInsn(INVOKESTATIC, ARRAYS, "asList",
                "([L" + OBJECT + ";)L" + LIST + ";", false);
        mv.visitInsn(ARETURN);
        
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
    
    private void generateGetIndex(ClassWriter cw) {
        // public int getIndex()
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "getIndex", "()I", null, null);
        mv.visitCode();
        
        // Push the component index constant
        if (componentIndex >= -1 && componentIndex <= 5) {
            mv.visitInsn(ICONST_0 + componentIndex);
        } else if (componentIndex >= Byte.MIN_VALUE && componentIndex <= Byte.MAX_VALUE) {
            mv.visitIntInsn(BIPUSH, componentIndex);
        } else if (componentIndex >= Short.MIN_VALUE && componentIndex <= Short.MAX_VALUE) {
            mv.visitIntInsn(SIPUSH, componentIndex);
        } else {
            mv.visitLdcInsn(componentIndex);
        }
        
        mv.visitInsn(IRETURN);
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
}
