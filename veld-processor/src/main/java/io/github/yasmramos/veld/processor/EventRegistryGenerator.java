package io.github.yasmramos.veld.processor;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;
import io.github.yasmramos.veld.annotation.EventRegistrationSPI;

import javax.lang.model.element.Modifier;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Generates the EventRegistry implementation class for zero-reflection event registration.
 *
 * <p>This class generates code that implements {@link io.github.yasmramos.veld.annotation.EventRegistrationSPI}
 * to register event handlers without using reflection at runtime.</p>
 *
 * <h2>Generated Code Structure</h2>
 * <pre>{@code
 * public class VeldEventRegistryImpl implements EventRegistrationSPI {
 *     private static final int HANDLER_COUNT = N;
 *
 *     @Override
 *     public void registerEvents(Object bus, Object component) {
 *         if (component == null) return;
 *         if (component instanceof ComponentA) {
 *             ComponentA a = (ComponentA) component;
 *             ((io.github.yasmramos.veld.runtime.event.EventBus) bus).registerEventHandler(EVENT_ID_A, a::handlerMethodA);
 *             ((io.github.yasmramos.veld.runtime.event.EventBus) bus).registerEventHandler(EVENT_ID_B, a::handlerMethodB);
 *         }
 *         if (component instanceof ComponentB) {
 *             ComponentB b = (ComponentB) component;
 *             ((io.github.yasmramos.veld.runtime.event.EventBus) bus).registerEventHandler(EVENT_ID_C, b::handlerMethodC);
 *         }
 *     }
 *
 *     @Override
 *     public int getHandlerCount() {
 *         return HANDLER_COUNT;
 *     }
 * }
 * }</pre>
 *
 * @author Veld Framework Team
 * @since 1.0.0
 */
public class EventRegistryGenerator {

    private static final String EVENT_BUS_FULL_NAME = "io.github.yasmramos.veld.runtime.event.EventBus";

    private final List<SubscriptionInfo> subscriptions;
    private final String packageName;
    private final String className;

    /**
     * Information about a single @Subscribe method.
     */
    public static class SubscriptionInfo {
        public final String componentClassName;
        public final String componentSimpleName;
        public final String methodName;
        public final String eventTypeName;
        public final int eventId;
        public final boolean async;
        public final int priority;

        public SubscriptionInfo(String componentClassName, String componentSimpleName,
                                 String methodName, String eventTypeName, int eventId,
                                 boolean async, int priority) {
            this.componentClassName = componentClassName;
            this.componentSimpleName = componentSimpleName;
            this.methodName = methodName;
            this.eventTypeName = eventTypeName;
            this.eventId = eventId;
            this.async = async;
            this.priority = priority;
        }
    }

    public EventRegistryGenerator(List<SubscriptionInfo> subscriptions) {
        this.subscriptions = subscriptions;
        this.packageName = "io.github.yasmramos.veld";
        this.className = "VeldEventRegistryImpl";
    }

    /**
     * Generates the complete Java source code for the event registry.
     *
     * @return the generated Java source code
     */
    public JavaFile generate() {
        // Build the class using JavaPoet
        TypeSpec.Builder classBuilder = TypeSpec.classBuilder(className)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addSuperinterface(ClassName.get(EventRegistrationSPI.class))
                .addJavadoc(
                        "Generated event registry for zero-reflection event registration.\n" +
                        "\n" +
                        "<p>This class is generated by VeldProcessor at compile time.\n" +
                        "It provides type-safe event handler registration without reflection.</p>\n" +
                        "\n" +
                        "@author Veld Framework (generated)\n")
                .addAnnotation(createGeneratedAnnotation());

        // Handler count constant
        FieldSpec handlerCountField = FieldSpec.builder(int.class, "HANDLER_COUNT")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                .initializer("$L", subscriptions.size())
                .build();
        classBuilder.addField(handlerCountField);

        // registerEvents method
        MethodSpec.Builder registerEventsMethod = MethodSpec.methodBuilder("registerEvents")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(void.class)
                .addParameter(ClassName.get(Object.class), "bus")
                .addParameter(ClassName.get(Object.class), "component")
                .beginControlFlow("if (component == null)")
                .addStatement("return")
                .endControlFlow();

        // Group subscriptions by component class
        Map<String, List<SubscriptionInfo>> byComponent = subscriptions.stream()
                .collect(Collectors.groupingBy(si -> si.componentClassName));

        // Generate registration for each component
        for (Map.Entry<String, List<SubscriptionInfo>> entry : byComponent.entrySet()) {
            String componentClass = entry.getKey();
            String simpleName = entry.getValue().get(0).componentSimpleName;
            List<SubscriptionInfo> componentSubs = entry.getValue();

            registerEventsMethod.addComment("Subscriptions for $N", simpleName)
                    .beginControlFlow("if (component instanceof $T)", ClassName.bestGuess(componentClass))
                    .addStatement("$T typed = ($T) component", ClassName.bestGuess(componentClass), ClassName.bestGuess(componentClass));

            for (SubscriptionInfo sub : componentSubs) {
                // Generate registration with typed event handler - using fully qualified EventBus name
                StringBuilder registration = new StringBuilder();
                registration.append("(($T) bus).registerEventHandler(")
                        .append(sub.eventId).append(", ")
                        .append(sub.eventTypeName).append(".class, ")
                        .append("($T event) -> typed.").append(sub.methodName).append("(event)");

                if (sub.async || sub.priority != 0) {
                    if (sub.priority != 0) {
                        registration.append(", ").append(sub.priority);
                    }
                    registration.append(")");
                } else {
                    registration.append(")");
                }
                registerEventsMethod.addStatement(registration.toString(),
                        ClassName.bestGuess(EVENT_BUS_FULL_NAME), ClassName.bestGuess(sub.eventTypeName));
            }

            registerEventsMethod.endControlFlow().addCode("\n");
        }

        classBuilder.addMethod(registerEventsMethod.build());

        // getHandlerCount method
        MethodSpec getHandlerCountMethod = MethodSpec.methodBuilder("getHandlerCount")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(int.class)
                .addStatement("return HANDLER_COUNT")
                .build();
        classBuilder.addMethod(getHandlerCountMethod);

        // Build JavaFile
        return JavaFile.builder(packageName, classBuilder.build()).build();
    }

    /**
     * Returns the fully qualified class name of the generated registry.
     *
     * @return the class name with package
     */
    public String getClassName() {
        return packageName + "." + className;
    }

    /**
     * Computes a simple event ID from the event type name.
     * Uses hashCode for compact representation.
     *
     * @param eventTypeName the fully qualified event type name
     * @return the event ID
     */
    public static int computeEventId(String eventTypeName) {
        return eventTypeName.hashCode();
    }
    
    /**
     * Creates the @Generated annotation for the generated event registry class.
     */
    private AnnotationSpec createGeneratedAnnotation() {
        return AnnotationSpec.builder(ClassName.get("javax.annotation.processing", "Generated"))
                .addMember("value", "$S", "io.github.yasmramos.veld.processor.VeldProcessor")
                .addMember("date", "$S", java.time.Instant.now().toString())
                .build();
    }
}
