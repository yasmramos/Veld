package io.github.yasmramos.veld.processor;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Generates the EventRegistry implementation class for zero-reflection event registration.
 *
 * <p>This class generates code that implements {@link io.github.yasmramos.veld.runtime.event.EventRegistrationSPI}
 * to register event handlers without using reflection at runtime.</p>
 *
 * <h2>Generated Code Structure</h2>
 * <pre>{@code
 * public class VeldEventRegistryImpl implements EventRegistrationSPI {
 *     private static final int HANDLER_COUNT = N;
 *
 *     @Override
 *     public void registerEvents(EventBus bus, Object component) {
 *         if (component instanceof ComponentA) {
 *             ComponentA a = (ComponentA) component;
 *             bus.registerEventHandler(EVENT_ID_A, a::handlerMethodA);
 *             bus.registerEventHandler(EVENT_ID_B, a::handlerMethodB);
 *         }
 *         if (component instanceof ComponentB) {
 *             ComponentB b = (ComponentB) component;
 *             bus.registerEventHandler(EVENT_ID_C, b::handlerMethodC);
 *         }
 *     }
 *
 *     @Override
 *     public int getHandlerCount() {
 *         return HANDLER_COUNT;
 *     }
 * }
 * }</pre>
 *
 * @author Veld Framework Team
 * @since 1.0.0
 */
public class EventRegistryGenerator {

    private final List<SubscriptionInfo> subscriptions;
    private final String packageName;
    private final String className;

    /**
     * Information about a single @Subscribe method.
     */
    public static class SubscriptionInfo {
        public final String componentClassName;
        public final String componentSimpleName;
        public final String methodName;
        public final String eventTypeName;
        public final int eventId;
        public final boolean async;
        public final int priority;

        public SubscriptionInfo(String componentClassName, String componentSimpleName,
                                 String methodName, String eventTypeName, int eventId,
                                 boolean async, int priority) {
            this.componentClassName = componentClassName;
            this.componentSimpleName = componentSimpleName;
            this.methodName = methodName;
            this.eventTypeName = eventTypeName;
            this.eventId = eventId;
            this.async = async;
            this.priority = priority;
        }
    }

    public EventRegistryGenerator(List<SubscriptionInfo> subscriptions) {
        this.subscriptions = subscriptions;
        this.packageName = "io.github.yasmramos.veld.generated";
        this.className = "VeldEventRegistryImpl";
    }

    /**
     * Generates the complete Java source code for the event registry.
     *
     * @return the generated Java source code
     */
    public String generate() {
        StringBuilder sb = new StringBuilder();

        // Package declaration
        sb.append("package ").append(packageName).append(";\n\n");

        // Imports
        sb.append("import io.github.yasmramos.veld.runtime.event.EventBus;\n");
        sb.append("import io.github.yasmramos.veld.runtime.event.EventRegistrationSPI;\n");
        sb.append("import java.util.function.Consumer;\n");
        sb.append("import io.github.yasmramos.veld.runtime.event.Event;\n\n");

        // Class declaration
        sb.append("/**\n");
        sb.append(" * Generated event registry for zero-reflection event registration.\n");
        sb.append(" *\n");
        sb.append(" * <p>This class is generated by VeldProcessor at compile time.\n");
        sb.append(" * It provides type-safe event handler registration without reflection.</p>\n");
        sb.append(" *\n");
        sb.append(" * @author Veld Framework (generated)\n");
        sb.append(" */\n");
        sb.append("public final class ").append(className).append(" implements EventRegistrationSPI {\n\n");

        // Handler count constant
        sb.append("    private static final int HANDLER_COUNT = ").append(subscriptions.size()).append(";\n\n");

        // registerEvents method
        sb.append("    @Override\n");
        sb.append("    public void registerEvents(EventBus bus, Object component) {\n");
        sb.append("        if (component == null) {\n");
        sb.append("            return;\n");
        sb.append("        }\n\n");

        // Group subscriptions by component class
        Map<String, List<SubscriptionInfo>> byComponent = subscriptions.stream()
                .collect(Collectors.groupingBy(si -> si.componentClassName));

        // Generate registration for each component
        for (Map.Entry<String, List<SubscriptionInfo>> entry : byComponent.entrySet()) {
            String componentClass = entry.getKey();
            String simpleName = entry.getValue().get(0).componentSimpleName;
            List<SubscriptionInfo> componentSubs = entry.getValue();

            sb.append("        // Subscriptions for ").append(simpleName).append("\n");
            sb.append("        if (component instanceof ").append(componentClass).append(") {\n");
            sb.append("            ").append(componentClass).append(" typed = (").append(componentClass).append(") component;\n");

            for (SubscriptionInfo sub : componentSubs) {
                String methodRef = "typed::" + sub.methodName;
                if (sub.async || sub.priority != 0) {
                    sb.append("            bus.registerEventHandler(")
                            .append(sub.eventId).append(", ")
                            .append(methodRef);
                    if (sub.priority != 0) {
                        sb.append(", ").append(sub.priority);
                    }
                    sb.append(");\n");
                } else {
                    sb.append("            bus.registerEventHandler(")
                            .append(sub.eventId).append(", ")
                            .append(methodRef).append(");\n");
                }
            }
            sb.append("        }\n\n");
        }

        sb.append("    }\n\n");

        // getHandlerCount method
        sb.append("    @Override\n");
        sb.append("    public int getHandlerCount() {\n");
        sb.append("        return HANDLER_COUNT;\n");
        sb.append("    }\n\n");

        // End of class
        sb.append("}\n");

        return sb.toString();
    }

    /**
     * Returns the fully qualified class name of the generated registry.
     *
     * @return the class name with package
     */
    public String getClassName() {
        return packageName + "." + className;
    }

    /**
     * Computes a simple event ID from the event type name.
     * Uses hashCode for compact representation.
     *
     * @param eventTypeName the fully qualified event type name
     * @return the event ID
     */
    public static int computeEventId(String eventTypeName) {
        return eventTypeName.hashCode();
    }
}
