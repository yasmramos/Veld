package com.veld.processor;

import com.veld.runtime.Scope;
import java.util.*;

/**
 * Generates Veld.java source code instead of bytecode.
 * This allows the generated class to be compiled alongside user code.
 * 
 * Same optimizations as VeldBootstrapGenerator:
 * - static final fields (JIT inlining)
 * - static initializer block (thread-safe initialization)
 * - Direct getters (2 bytecode instructions after JIT)
 * - Array-based lookup (no Maps)
 */
public class VeldSourceGenerator {
    
    private static final String PACKAGE = "com.veld.generated";
    private static final String CLASS_NAME = "Veld";
    
    private final List<ComponentInfo> components;
    
    public VeldSourceGenerator(List<ComponentInfo> components) {
        this.components = components;
    }
    
    public String generate() {
        StringBuilder sb = new StringBuilder();
        
        // Package
        sb.append("package ").append(PACKAGE).append(";\n\n");
        
        // Imports
        sb.append("import java.util.ArrayList;\n");
        sb.append("import java.util.List;\n\n");
        
        // Class
        sb.append("/**\n");
        sb.append(" * Ultra-fast DI container - generated by Veld.\n");
        sb.append(" * All singletons initialized in static block (thread-safe, zero runtime overhead).\n");
        sb.append(" */\n");
        sb.append("public final class ").append(CLASS_NAME).append(" {\n\n");
        
        // Separate singletons and prototypes
        List<ComponentInfo> singletons = new ArrayList<>();
        List<ComponentInfo> prototypes = new ArrayList<>();
        for (ComponentInfo comp : components) {
            if (comp.getScope() == Scope.SINGLETON) {
                singletons.add(comp);
            } else {
                prototypes.add(comp);
            }
        }
        
        // Generate fields for singletons
        sb.append("    // === SINGLETON FIELDS (static final = JIT inlines) ===\n");
        for (ComponentInfo comp : singletons) {
            sb.append("    private static final ").append(comp.getClassName())
              .append(" ").append(getFieldName(comp)).append(";\n");
        }
        sb.append("\n");
        
        // Generate lookup arrays
        sb.append("    // === LOOKUP ARRAYS ===\n");
        sb.append("    private static final Class<?>[] _types;\n");
        sb.append("    private static final Object[] _instances;\n");
        sb.append("    private static final int[] _scopes;\n");
        sb.append("    private static final int[] _protoIdx;\n\n");
        
        // Static initializer
        sb.append("    // === STATIC INITIALIZER (JVM guarantees thread-safety) ===\n");
        sb.append("    static {\n");
        
        // Topologically sort singletons
        List<ComponentInfo> sorted = topologicalSort(singletons);
        
        // Initialize singletons
        for (ComponentInfo comp : sorted) {
            sb.append("        ").append(getFieldName(comp)).append(" = new ")
              .append(comp.getClassName()).append("(");
            
            InjectionPoint constructor = comp.getConstructorInjection();
            if (constructor != null && !constructor.getDependencies().isEmpty()) {
                List<String> args = new ArrayList<>();
                for (InjectionPoint.Dependency dep : constructor.getDependencies()) {
                    ComponentInfo depComp = findComponentByType(dep.getTypeName().replace('.', '/'));
                    if (depComp != null) {
                        if (depComp.getScope() == Scope.SINGLETON) {
                            args.add(getFieldName(depComp));
                        } else {
                            args.add(getMethodName(depComp) + "()");
                        }
                    } else {
                        args.add("null");
                    }
                }
                sb.append(String.join(", ", args));
            }
            sb.append(");\n");
        }
        
        sb.append("\n");
        
        // Initialize arrays
        List<TypeMapping> mappings = buildTypeMappings();
        sb.append("        _types = new Class<?>[] {\n");
        for (int i = 0; i < mappings.size(); i++) {
            sb.append("            ").append(mappings.get(i).typeName).append(".class");
            if (i < mappings.size() - 1) sb.append(",");
            sb.append("\n");
        }
        sb.append("        };\n");
        
        sb.append("        _instances = new Object[] {\n");
        for (int i = 0; i < mappings.size(); i++) {
            TypeMapping m = mappings.get(i);
            if (m.component.getScope() == Scope.SINGLETON) {
                sb.append("            ").append(getFieldName(m.component));
            } else {
                sb.append("            null");
            }
            if (i < mappings.size() - 1) sb.append(",");
            sb.append("\n");
        }
        sb.append("        };\n");
        
        // Build prototype index map
        Map<String, Integer> protoIdxMap = new HashMap<>();
        for (int p = 0; p < prototypes.size(); p++) {
            protoIdxMap.put(prototypes.get(p).getClassName(), p);
        }
        
        sb.append("        _scopes = new int[] {\n");
        for (int i = 0; i < mappings.size(); i++) {
            TypeMapping m = mappings.get(i);
            sb.append("            ").append(m.component.getScope() == Scope.SINGLETON ? "0" : "1");
            if (i < mappings.size() - 1) sb.append(",");
            sb.append("\n");
        }
        sb.append("        };\n");
        
        sb.append("        _protoIdx = new int[] {\n");
        for (int i = 0; i < mappings.size(); i++) {
            TypeMapping m = mappings.get(i);
            Integer idx = protoIdxMap.get(m.component.getClassName());
            sb.append("            ").append(idx != null ? idx : -1);
            if (i < mappings.size() - 1) sb.append(",");
            sb.append("\n");
        }
        sb.append("        };\n");
        sb.append("    }\n\n");
        
        // Private constructor
        sb.append("    private Veld() {}\n\n");
        
        // Generate singleton getters
        sb.append("    // === DIRECT GETTERS (ultra-fast) ===\n");
        for (ComponentInfo comp : singletons) {
            sb.append("    public static ").append(comp.getClassName()).append(" ")
              .append(getMethodName(comp)).append("() {\n");
            sb.append("        return ").append(getFieldName(comp)).append(";\n");
            sb.append("    }\n\n");
        }
        
        // Generate prototype getters
        for (ComponentInfo comp : prototypes) {
            sb.append("    public static ").append(comp.getClassName()).append(" ")
              .append(getMethodName(comp)).append("() {\n");
            sb.append("        return new ").append(comp.getClassName()).append("(");
            
            InjectionPoint constructor = comp.getConstructorInjection();
            if (constructor != null && !constructor.getDependencies().isEmpty()) {
                List<String> args = new ArrayList<>();
                for (InjectionPoint.Dependency dep : constructor.getDependencies()) {
                    ComponentInfo depComp = findComponentByType(dep.getTypeName().replace('.', '/'));
                    if (depComp != null) {
                        args.add(getMethodName(depComp) + "()");
                    } else {
                        args.add("null");
                    }
                }
                sb.append(String.join(", ", args));
            }
            sb.append(");\n");
            sb.append("    }\n\n");
        }
        
        // Generate container API
        generateContainerAPI(sb, prototypes);
        
        sb.append("}\n");
        
        return sb.toString();
    }
    
    private void generateContainerAPI(StringBuilder sb, List<ComponentInfo> prototypes) {
        sb.append("    // === CONTAINER API ===\n\n");
        
        // _createPrototype switch method
        sb.append("    private static Object _createPrototype(int idx) {\n");
        sb.append("        switch (idx) {\n");
        for (int i = 0; i < prototypes.size(); i++) {
            sb.append("            case ").append(i).append(": return ")
              .append(getMethodName(prototypes.get(i))).append("();\n");
        }
        sb.append("            default: return null;\n");
        sb.append("        }\n");
        sb.append("    }\n\n");
        
        // get(Class)
        sb.append("    @SuppressWarnings(\"unchecked\")\n");
        sb.append("    public static <T> T get(Class<T> type) {\n");
        sb.append("        for (int i = 0; i < _types.length; i++) {\n");
        sb.append("            if (_types[i] == type) {\n");
        sb.append("                if (_scopes[i] == 0) {\n");
        sb.append("                    return (T) _instances[i];\n");
        sb.append("                } else {\n");
        sb.append("                    return (T) _createPrototype(_protoIdx[i]);\n");
        sb.append("                }\n");
        sb.append("            }\n");
        sb.append("        }\n");
        sb.append("        return null;\n");
        sb.append("    }\n\n");
        
        // getAll(Class)
        sb.append("    @SuppressWarnings(\"unchecked\")\n");
        sb.append("    public static <T> List<T> getAll(Class<T> type) {\n");
        sb.append("        List<T> result = new ArrayList<>();\n");
        sb.append("        for (int i = 0; i < _types.length; i++) {\n");
        sb.append("            if (type.isAssignableFrom(_types[i])) {\n");
        sb.append("                result.add((T) _instances[i]);\n");
        sb.append("            }\n");
        sb.append("        }\n");
        sb.append("        return result;\n");
        sb.append("    }\n\n");
        
        // contains(Class)
        sb.append("    public static boolean contains(Class<?> type) {\n");
        sb.append("        return get(type) != null;\n");
        sb.append("    }\n\n");
        
        // componentCount()
        sb.append("    public static int componentCount() {\n");
        sb.append("        return ").append(components.size()).append(";\n");
        sb.append("    }\n");
    }
    
    private List<TypeMapping> buildTypeMappings() {
        List<TypeMapping> mappings = new ArrayList<>();
        for (ComponentInfo comp : components) {
            mappings.add(new TypeMapping(comp.getClassName(), comp));
            for (String iface : comp.getImplementedInterfaces()) {
                mappings.add(new TypeMapping(iface, comp));
            }
        }
        return mappings;
    }
    
    private static class TypeMapping {
        final String typeName;
        final ComponentInfo component;
        TypeMapping(String typeName, ComponentInfo component) {
            this.typeName = typeName;
            this.component = component;
        }
    }
    
    private List<ComponentInfo> topologicalSort(List<ComponentInfo> singletons) {
        Map<String, ComponentInfo> byType = new HashMap<>();
        for (ComponentInfo comp : singletons) {
            byType.put(comp.getInternalName(), comp);
            for (String iface : comp.getImplementedInterfacesInternal()) {
                byType.put(iface, comp);
            }
        }
        
        Set<String> visited = new HashSet<>();
        Set<String> visiting = new HashSet<>();
        List<ComponentInfo> result = new ArrayList<>();
        
        for (ComponentInfo comp : singletons) {
            visit(comp, byType, visited, visiting, result);
        }
        
        return result;
    }
    
    private void visit(ComponentInfo comp, Map<String, ComponentInfo> byType,
                       Set<String> visited, Set<String> visiting, List<ComponentInfo> result) {
        String key = comp.getInternalName();
        if (visited.contains(key)) return;
        if (visiting.contains(key)) return;
        
        visiting.add(key);
        
        InjectionPoint constructor = comp.getConstructorInjection();
        if (constructor != null) {
            for (InjectionPoint.Dependency dep : constructor.getDependencies()) {
                String depType = dep.getTypeName().replace('.', '/');
                ComponentInfo depComp = byType.get(depType);
                if (depComp != null && depComp.getScope() == Scope.SINGLETON) {
                    visit(depComp, byType, visited, visiting, result);
                }
            }
        }
        
        visiting.remove(key);
        visited.add(key);
        result.add(comp);
    }
    
    private ComponentInfo findComponentByType(String internalName) {
        for (ComponentInfo comp : components) {
            if (comp.getInternalName().equals(internalName)) {
                return comp;
            }
            for (String iface : comp.getImplementedInterfacesInternal()) {
                if (iface.equals(internalName)) {
                    return comp;
                }
            }
        }
        return null;
    }
    
    private String getMethodName(ComponentInfo comp) {
        String simpleName = comp.getClassName();
        int lastDot = simpleName.lastIndexOf('.');
        if (lastDot >= 0) {
            simpleName = simpleName.substring(lastDot + 1);
        }
        if (simpleName.length() > 1 && Character.isUpperCase(simpleName.charAt(1))) {
            return simpleName;
        }
        return Character.toLowerCase(simpleName.charAt(0)) + simpleName.substring(1);
    }
    
    private String getFieldName(ComponentInfo comp) {
        return "_" + getMethodName(comp);
    }
    
    public String getFullClassName() {
        return PACKAGE + "." + CLASS_NAME;
    }
}
