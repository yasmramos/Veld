<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Annotations Reference - Veld DI Framework</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <a href="index.html" class="logo">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;">
                        <path d="M12 2L2 7v10c0 5.55 3.84 9.74 9 11 5.16-1.26 9-5.45 9-11V7l-10-5z"/>
                    </svg>
                    Veld
                </a>
                
                <nav>
                    <ul class="nav-menu">
                        <li><a href="getting-started.html">Getting Started</a></li>
                        <li><a href="annotations.html" class="active">Annotations</a></li>
                        <li><a href="core-features.html">Core Features</a></li>
                        <li><a href="aop.html">AOP</a></li>
                        <li><a href="eventbus.html">EventBus</a></li>
                <li><a href="spring-boot.html">Spring Boot Integration</a></li>
                        <li><a href="spring-boot.html">Spring Boot</a></li>
                        <li><a href="spring-boot.html">Spring Boot</a></li>
                        <li><a href="api.html">API Reference</a></li>
                        <li><a href="examples.html">Examples</a></li>
                    </ul>
                </nav>
                
                <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">‚ò∞</button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-layout">
        <!-- Sidebar Navigation -->
        <nav class="sidebar">
            <h3>Documentation</h3>
            <ul class="sidebar-nav">
                <li><a href="index.html">Overview</a></li>
                <li><a href="getting-started.html">Getting Started</a></li>
                <li><a href="installation.html">Installation</a></li>
                <li><a href="annotations.html" class="active">Annotations Reference</a></li>
                <li>
                    <a href="core-features.html">Core Features</a>
                    <ul class="sub-nav">
                        <li><a href="core-features.html#dependency-injection">Dependency Injection</a></li>
                        <li><a href="core-features.html#scopes">Scopes</a></li>
                        <li><a href="core-features.html#configuration">Configuration</a></li>
                        <li><a href="core-features.html#lifecycle">Lifecycle</a></li>
                    </ul>
                </li>
                <li><a href="aop.html">Aspect-Oriented Programming</a></li>
                <li><a href="eventbus.html">EventBus</a></li>
                <li><a href="spring-boot.html">Spring Boot Integration</a></li>
                        <li><a href="spring-boot.html">Spring Boot</a></li>
                <li><a href="spring-boot.html">Spring Boot Integration</a></li>
                <li><a href="optimizations.html">Phase 1 Optimizations</a></li>
                <li><a href="api.html">API Reference</a></li>
                <li><a href="examples.html">Examples</a></li>
            </ul>
        </nav>

        <!-- Content -->
        <div class="content">
            <h1>üìù Annotations Reference</h1>
            
            <div class="alert alert-info">
                <strong>üìö Overview:</strong> This reference covers all Veld annotations, their parameters, and usage examples. Veld is fully compatible with JSR-330 and Jakarta Inject standards.
            </div>

            <!-- Component Annotations -->
            <section>
                <h2>üèóÔ∏è Component Annotations</h2>
                
                <div class="card" id="component">
                    <h3>@Component</h3>
                    <p>Primary annotation for defining components managed by Veld.</p>
                    
                    <h4>Parameters</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>name()</code></td>
                                <td><code>String</code></td>
                                <td><code>""</code></td>
                                <td>Optional component name for explicit referencing</td>
                            </tr>
                            <tr>
                                <td><code>modules()</code></td>
                                <td><code>Class&lt;?&gt;[]</code></td>
                                <td><code>{}</code></td>
                                <td>Additional modules to import for this component</td>
                            </tr>
                        </tbody>
                    </table>

                    <h4>Basic Usage</h4>
<pre><code>@Component
public class MyService {
    // This class will be managed by Veld
}</code></pre>

                    <h4>With Custom Name</h4>
<pre><code>@Component(name = "myCustomService")
public class MyService {
    // Can be referenced as "myCustomService"
}</code></pre>

                    <h4>With Module Import</h4>
<pre><code>@Component(modules = {DatabaseModule.class})
public class DatabaseService {
    // Imports additional dependencies from DatabaseModule
}</code></pre>
                </div>

                <div class="card" id="module">
                    <h3>@Module</h3>
                    <p>Groups related components and provides configuration for dependency injection.</p>
                    
                    <h4>Parameters</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>includes()</code></td>
                                <td><code>Class&lt;?&gt;[]</code></td>
                                <td><code>{}</code></td>
                                <td>Other modules to include</td>
                            </tr>
                        </tbody>
                    </table>

                    <h4>Usage</h4>
<pre><code>@Module
public class DatabaseModule {
    
    @Component
    @Singleton
    public DatabaseConnection createConnection() {
        return new DatabaseConnection("jdbc:postgresql://localhost:5432/mydb");
    }
}</code></pre>
                </div>

                <div class="card" id="primary">
                    <h3>@Primary</h3>
                    <p>Indicates that a component should be preferred when multiple candidates exist for injection.</p>
                    
                    <h4>Usage</h4>
<pre><code>@Component
@Primary
public class ProductionDatabase implements Database {
    // This implementation will be preferred
}

@Component
public class MockDatabase implements Database {
    // This will only be used if explicitly requested
}</code></pre>
                </div>

                <div class="card" id="order">
                    <h3>@Order</h3>
                    <p>Specifies the order of components when multiple implementations exist.</p>
                    
                    <h4>Parameters</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>value()</code></td>
                                <td><code>int</code></td>
                                <td>Priority order (lower numbers have higher priority)</td>
                            </tr>
                        </tbody>
                    </table>

                    <h4>Usage</h4>
<pre><code>@Component
@Order(1)
public class HighPriorityService implements ServiceInterface {
    // Will be processed first
}

@Component
@Order(2)
public class LowPriorityService implements ServiceInterface {
    // Will be processed second
}</code></pre>
                </div>
            </section>

            <!-- Injection Annotations -->
            <section>
                <h2>üíâ Injection Annotations</h2>
                
                <div class="card" id="inject">
                    <h3>@Inject</h3>
                    <p>Primary annotation for dependency injection. Can be used on constructors, fields, and methods.</p>
                    
                    <h4>Constructor Injection (Recommended)</h4>
<pre><code>@Component
@Singleton
public class UserService {
    private final UserRepository userRepository;
    
    @Inject
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}</code></pre>

                    <h4>Field Injection</h4>
<pre><code>@Component
@Singleton
public class OrderService {
    
    @Inject
    private UserRepository userRepository;
    
    @Inject
    private OrderRepository orderRepository;
}</code></pre>

                    <h4>Method Injection</h4>
<pre><code>@Component
@Singleton
public class NotificationService {
    private EmailService emailService;
    
    @Inject
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
}</code></pre>
                </div>

                <div class="card" id="optional">
                    <h3>@Optional</h3>
                    <p>Allows injection of dependencies that may not be present.</p>
                    
                    <h4>Usage</h4>
<pre><code>@Component
public class ConfigService {
    
    @Inject
    @Optional
    private Optional&lt;CacheService&gt; cacheService;  // Won't fail if CacheService is missing
    
    public void initialize() {
        cacheService.ifPresent(service -&gt; {
            System.out.println("Cache service available");
        });
    }
}</code></pre>

                    <div class="alert alert-warning">
                        <strong>‚ö†Ô∏è Note:</strong> When using @Optional, the dependency resolution won't fail if the target component is not found.
                    </div>
                </div>

                <div class="card" id="provider">
                    <h3>@Provider</h3>
                    <p>Provides lazy instantiation and on-demand creation of components.</p>
                    
                    <h4>Usage</h4>
<pre><code>@Component
@Singleton
public class ExpensiveService {
    public ExpensiveService() {
        System.out.println("ExpensiveService created");
    }
}

@Component
public class ClientService {
    
    @Inject
    private Provider&lt;ExpensiveService&gt; expensiveServiceProvider;
    
    public void doWork() {
        // ExpensiveService is created only when needed
        ExpensiveService service = expensiveServiceProvider.get();
        service.performExpensiveOperation();
    }
}</code></pre>
                </div>

                <div class="card" id="value">
                    <h3>@Value</h3>
                    <p>Injects configuration values from various sources.</p>
                    
                    <h4>Sources (in order of precedence)</h4>
                    <ol>
                        <li>System properties</li>
                        <li>Environment variables</li>
                        <li>Configuration files</li>
                        <li>Default values</li>
                    </ol>

                    <h4>Basic Usage</h4>
<pre><code>@Component
public class AppConfig {
    
    @Value("${app.name}")
    private String appName;
    
    @Value("${database.url}")
    private String databaseUrl;
    
    @Value("${cache.timeout:30}")  // Default value
    private int cacheTimeout;
}</code></pre>

                    <h4>System Properties</h4>
<pre><code>// JVM arguments
-Dapp.name=MyApp
-Ddatabase.url=jdbc:postgresql://localhost:5432/mydb</code></pre>

                    <h4>Environment Variables</h4>
<pre><code>// Shell environment
export APP_NAME=MyApp
export DATABASE_URL=jdbc:postgresql://localhost:5432/mydb</code></pre>

                    <h4>Configuration Files</h4>
                    <p>Create <code>application.properties</code>:</p>
<pre><code>app.name=MyApp
database.url=jdbc:postgresql://localhost:5432/mydb
cache.timeout=30</code></pre>

                    <p>Or <code>application.yml</code>:</p>
<pre><code>app:
  name: MyApp
database:
  url: jdbc:postgresql://localhost:5432/mydb
cache:
  timeout: 30</code></pre>
                </div>
            </section>

            <!-- Scope Annotations -->
            <section>
                <h2>üîÑ Scope Annotations</h2>
                
                <div class="card" id="singleton">
                    <h3>@Singleton</h3>
                    <p>Creates a single instance of the component for the entire application context.</p>
                    
                    <h4>Usage</h4>
<pre><code>@Component
@Singleton
public class DatabaseService {
    // Only one instance created and shared
}</code></pre>

                    <h4>Lazy Singleton</h4>
<pre><code>@Component
@Singleton
@Lazy
public class ExpensiveService {
    // Instance created only when first accessed
}</code></pre>
                </div>

                <div class="card" id="prototype">
                    <h3>@Prototype</h3>
                    <p>Creates a new instance of the component for each injection.</p>
                    
                    <h4>Usage</h4>
<pre><code>@Component
@Prototype
public class RequestHandler {
    // New instance created for each injection
}</code></pre>

                    <div class="alert alert-info">
                        <strong>üí° Tip:</strong> Use @Prototype for stateless components or when you need a fresh instance for each use.
                    </div>
                </div>

                <div class="card" id="lazy">
                    <h3>@Lazy</h3>
                    <p>Defers component creation until the component is first accessed.</p>
                    
                    <h4>Usage</h4>
<pre><code>@Component
@Lazy
public class HeavyInitializationService {
    // Created only when first needed
}</code></pre>

                    <h4>Lazy with Provider</h4>
<pre><code>@Component
public class ServiceClient {
    
    @Inject
    @Lazy
    private Provider&lt;HeavyInitializationService&gt; heavyServiceProvider;
    
    public void doWork() {
        // HeavyInitializationService created only when get() is called
        heavyServiceProvider.get().performWork();
    }
}</code></pre>
                </div>
            </section>

            <!-- Lifecycle Annotations -->
            <section>
                <h2>üîÑ Lifecycle Annotations</h2>
                
                <div class="card" id="postconstruct">
                    <h3>@PostConstruct</h3>
                    <p>Indicates a method that should be called after dependency injection is complete.</p>
                    
                    <h4>Usage</h4>
<pre><code>@Component
@Singleton
public class DatabaseService {
    
    private Connection connection;
    
    @PostConstruct
    public void initialize() {
        // Called after all dependencies are injected
        this.connection = createConnection();
        System.out.println("DatabaseService initialized");
    }
}</code></pre>
                </div>

                <div class="card" id="predestroy">
                    <h3>@PreDestroy</h3>
                    <p>Indicates a method that should be called before the component is destroyed.</p>
                    
                    <h4>Usage</h4>
<pre><code>@Component
@Singleton
public class DatabaseService {
    
    private Connection connection;
    
    @PreDestroy
    public void cleanup() {
        // Called before component destruction
        if (connection != null) {
            connection.close();
        }
        System.out.println("DatabaseService cleanup completed");
    }
}</code></pre>
                </div>
            </section>

            <!-- Conditional Annotations -->
            <section>
                <h2>üîÄ Conditional Annotations</h2>
                
                <div class="card" id="conditionalonproperty">
                    <h3>@ConditionalOnProperty</h3>
                    <p>Registers a component only if a specific property matches a condition.</p>
                    
                    <h4>Parameters</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>name()</code></td>
                                <td><code>String</code></td>
                                <td>Property name to check</td>
                            </tr>
                            <tr>
                                <td><code>value()</code></td>
                                <td><code>String</code></td>
                                <td>Expected value (optional)</td>
                            </tr>
                            <tr>
                                <td><code>havingValue()</code></td>
                                <td><code>String</code></td>
                                <td>Value that must match</td>
                            </tr>
                            <tr>
                                <td><code>matchIfMissing()</code></td>
                                <td><code>boolean</code></td>
                                <td>Match if property is missing</td>
                            </tr>
                        </tbody>
                    </table>

                    <h4>Usage</h4>
<pre><code>@Component
@ConditionalOnProperty(name = "app.environment", havingValue = "production")
public class ProductionDatabaseService {
    // Only registered in production environment
}

@Component
@ConditionalOnProperty(name = "feature.cache.enabled", matchIfMissing = true)
public class CacheService {
    // Registered if property is missing or true
}</code></pre>
                </div>

                <div class="card" id="conditionalonclass">
                    <h3>@ConditionalOnClass</h3>
                    <p>Registers a component only if specific classes are available on the classpath.</p>
                    
                    <h4>Usage</h4>
<pre><code>@Component
@ConditionalOnClass(name = "com.fasterxml.jackson.databind.ObjectMapper")
public class JacksonConfig {
    // Only registered if Jackson is available
}

@Component
@ConditionalOnClass(name = {"com.redis.clients.jedis.Jedis", "redis.clients.jedis.Jedis"})
public class RedisService {
    // Only registered if Jedis Redis client is available
}</code></pre>
                </div>

                <div class="card" id="conditionalonmissingbean">
                    <h3>@ConditionalOnMissingBean</h3>
                    <p>Registers a component only if no other bean of the same type exists.</p>
                    
                    <h4>Usage</h4>
<pre><code>// Base configuration
@Component
@ConditionalOnProperty(name = "app.cache.type", havingValue = "redis")
public class RedisCache implements Cache {
    // Redis cache implementation
}

// Default fallback
@Component
@ConditionalOnMissingBean
public class InMemoryCache implements Cache {
    // In-memory cache (only used if Redis is not configured)
}</code></pre>
                </div>
            </section>

            <!-- AOP Annotations -->
            <section>
                <h2>üéØ AOP Annotations</h2>
                
                <div class="card" id="aspect">
                    <h3>@Aspect</h3>
                    <p>Defines a class as an aspect for cross-cutting concerns.</p>
                    
                    <h4>Usage</h4>
<pre><code>@Aspect
@Component
public class LoggingAspect {
    
    @Around("execution(* com.example.service.*.*(..))")
    public Object logMethodCall(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();
        
        try {
            Object result = joinPoint.proceed();
            long duration = System.currentTimeMillis() - start;
            System.out.println(joinPoint.getSignature() + " executed in " + duration + "ms");
            return result;
        } catch (Exception e) {
            System.out.println("Exception in " + joinPoint.getSignature() + ": " + e.getMessage());
            throw e;
        }
    }
}</code></pre>
                </div>

                <div class="card" id="around">
                    <h3>@Around</h3>
                    <p>Defines advice that wraps method execution.</p>
                    
                    <h4>Usage</h4>
<pre><code>@Aspect
@Component
public class TransactionAspect {
    
    @Around("execution(* com.example.service.*.*(..)) && @annotation(Transactional)")
    public Object manageTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
        // Begin transaction
        
        try {
            Object result = joinPoint.proceed();
            // Commit transaction
            return result;
        } catch (Exception e) {
            // Rollback transaction
            throw e;
        }
    }
}</code></pre>
                </div>

                <div class="card" id="interceptor">
                    <h3>@Interceptor</h3>
                    <p>Defines a CDI interceptor for method interception.</p>
                    
                    <h4>Usage</h4>
<pre><code>@Interceptor
@Component
public class TimingInterceptor {
    
    @AroundInvoke
    public Object measureTime(InvocationContext context) throws Exception {
        long start = System.nanoTime();
        
        try {
            return context.proceed();
        } finally {
            long duration = System.nanoTime() - start;
            System.out.println(context.getMethod().getName() + " took " + duration + "ns");
        }
    }
}</code></pre>
                </div>
            </section>

            <!-- Event Annotations -->
            <section>
                <h2>üì° Event Annotations</h2>
                
                <div class="card" id="subscribe">
                    <h3>@Subscribe</h3>
                    <p>Indicates a method that should receive events from the EventBus.</p>
                    
                    <h4>Usage</h4>
<pre><code>@Component
public class OrderEventHandler {
    
    @Subscribe
    public void handleOrderCreated(OrderCreatedEvent event) {
        System.out.println("Order created: " + event.getOrderId());
        // Send confirmation email, update inventory, etc.
    }
    
    @Subscribe
    public void handleOrderShipped(OrderShippedEvent event) {
        System.out.println("Order shipped: " + event.getOrderId());
        // Update tracking information, notify customer, etc.
    }
}</code></pre>

                    <h4>Async Event Handling</h4>
<pre><code>@Component
public class AsyncEventHandler {
    
    @Subscribe(async = true)
    public void handleHeavyEvent(HeavyEvent event) {
        // This method runs in a separate thread
        processHeavyEvent(event);
    }
}</code></pre>

                    <h4>Event Publishing</h4>
<pre><code>@Component
public class OrderService {
    
    @Inject
    private EventBus eventBus;
    
    public void createOrder(Order order) {
        // Save order to database
        Order savedOrder = orderRepository.save(order);
        
        // Publish event
        eventBus.publish(new OrderCreatedEvent(savedOrder.getId()));
    }
}</code></pre>
                </div>
            </section>

            <!-- JSR-330 Compatibility -->
            <section>
                <h2>üîÑ JSR-330 & Jakarta Inject Compatibility</h2>
                
                <div class="alert alert-success">
                    <strong>‚úÖ Full Compatibility:</strong> Veld supports standard JSR-330 and Jakarta Inject annotations alongside Veld-specific annotations.
                </div>

                <h3>JSR-330 Annotations</h3>
<pre><code>import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import javax.inject.Provider;

@Component
@Singleton
public class JSR330Service {
    
    @Inject
    private JSR330Repository repository;
    
    @Inject
    private Provider&lt;ExpensiveService&gt; serviceProvider;
}

@Component
@Named("customService")
public class NamedService {
    // Can be injected by name
}</code></pre>

                <h3>Jakarta Inject Annotations</h3>
<pre><code>import jakarta.inject.Inject;
import jakarta.inject.Named;
import jakarta.inject.Singleton;
import jakarta.inject.Provider;

@Component
@Singleton
public class JakartaService {
    
    @Inject
    private JakartaRepository repository;
}</code></pre>

                <h3>Mixed Usage</h3>
<pre><code>@Component
@Singleton
public class MixedService {
    
    @Inject  // Veld annotation
    private VeldComponent veldComponent;
    
    @Inject  // JSR-330 annotation
    private JSR330Component jsr330Component;
    
    @Inject  // Jakarta annotation
    private JakartaComponent jakartaComponent;
}</code></pre>
            </section>

            <!-- Custom Annotations -->
            <section>
                <h2>üé® Custom Annotations</h2>
                
                <div class="card">
                    <h3>Creating Custom Stereotype Annotations</h3>
                    <p>Combine multiple annotations for cleaner code:</p>
                    
<pre><code>// Define custom stereotype
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Component
@Singleton
public @interface Service {
    // No additional parameters needed
}

// Use the custom annotation
@Service
public class UserService {
    // Automatically has @Component and @Singleton
}</code></pre>
                </div>

                <div class="card">
                    <h3>Custom Injection Annotations</h3>
                    
<pre><code>// Custom annotation for configuration injection
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface ConfigValue {
    String value();
    String defaultValue() default "";
}

// Usage
@Component
public class ConfigService {
    
    @ConfigValue("app.name")
    private String appName;
    
    @ConfigValue("database.url")
    private String dbUrl;
}</code></pre>
                </div>
            </section>

            <!-- Best Practices -->
            <section>
                <h2>üí° Best Practices</h2>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <div class="feature-icon">üèóÔ∏è</div>
                        <h3>Constructor Injection</h3>
                        <p>Prefer constructor injection for mandatory dependencies. This makes dependencies explicit and enables better testing.</p>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon">üîí</div>
                        <h3>Final Fields</h3>
                        <p>Use final fields with constructor injection to ensure immutability and thread safety.</p>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon">‚ö°</div>
                        <h3>Lazy Loading</h3>
                        <p>Use @Lazy and Provider for expensive-to-create dependencies that may not always be needed.</p>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon">üéØ</div>
                        <h3>Conditional Beans</h3>
                        <p>Use @ConditionalOnProperty and @ConditionalOnClass to create environment-specific configurations.</p>
                    </div>
                </div>

                <div class="card">
                    <h3>Common Patterns</h3>
                    
                    <h4>Factory Pattern</h4>
<pre><code>@Component
@Singleton
public class ServiceFactory {
    
    @Inject
    private Map&lt;String, Service&gt; services;
    
    public Service getService(String type) {
        return services.get(type);
    }
}</code></pre>

                    <h4>Configuration Properties</h4>
<pre><code>@Component
public class AppProperties {
    
    @Value("${app.name}")
    private String name;
    
    @Value("${app.version}")
    private String version;
    
    @Value("${app.debug:false}")
    private boolean debug;
    
    // Getters
    public String getName() { return name; }
    public String getVersion() { return version; }
    public boolean isDebug() { return debug; }
}</code></pre>

                    <h4>Event-Driven Architecture</h4>
<pre><code>// Event definition
public record UserRegisteredEvent(String userId, String email) {}

// Event publisher
@Component
public class UserService {
    
    @Inject
    private EventBus eventBus;
    
    public void registerUser(String email) {
        String userId = createUser(email);
        eventBus.publish(new UserRegisteredEvent(userId, email));
    }
}

// Event handler
@Component
public class WelcomeEmailHandler {
    
    @Subscribe
    public void handleUserRegistration(UserRegisteredEvent event) {
        sendWelcomeEmail(event.email());
    }
}</code></pre>
                </div>
            </section>
        </div>
    </main>

    <!-- Scroll to Top Button -->
    <button id="scroll-to-top" class="scroll-to-top" onclick="scrollToTop()">‚Üë</button>

    <!-- Scripts -->
    <script src="js/main.js"></script>
</body>
</html>